<?xml version="1.0" encoding="UTF-8"?>
<!-- This file was generated on Thu Sep 15, 2022 15:35 (UTC) by REx v5.55 which is Copyright (c) 1979-2022 by Gunther Rademacher <grd@gmx.net> -->
<!-- REx command line: xpath-31.ebnf -xslt -tree -name xpath31 -->

<xsl:stylesheet version="2.0"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:p="tag:dmaus@dmaus.name,2022:Schematron-Schematron:XPath31">
  <!--~
   ! The index of the lexer state for accessing the combined
   ! (i.e. level > 1) lookahead code.
  -->
  <xsl:variable name="p:lk" as="xs:integer" select="1"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the token that has been consumed.
  -->
  <xsl:variable name="p:b0" as="xs:integer" select="2"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the token that has been consumed.
  -->
  <xsl:variable name="p:e0" as="xs:integer" select="3"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-1-lookahead token.
  -->
  <xsl:variable name="p:l1" as="xs:integer" select="4"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-1-lookahead token.
  -->
  <xsl:variable name="p:b1" as="xs:integer" select="5"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-1-lookahead token.
  -->
  <xsl:variable name="p:e1" as="xs:integer" select="6"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-2-lookahead token.
  -->
  <xsl:variable name="p:l2" as="xs:integer" select="7"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-2-lookahead token.
  -->
  <xsl:variable name="p:b2" as="xs:integer" select="8"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-2-lookahead token.
  -->
  <xsl:variable name="p:e2" as="xs:integer" select="9"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-3-lookahead token.
  -->
  <xsl:variable name="p:l3" as="xs:integer" select="10"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-3-lookahead token.
  -->
  <xsl:variable name="p:b3" as="xs:integer" select="11"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-3-lookahead token.
  -->
  <xsl:variable name="p:e3" as="xs:integer" select="12"/>

  <!--~
   ! The index of the lexer state for accessing the token code that
   ! was expected when an error was found.
  -->
  <xsl:variable name="p:error" as="xs:integer" select="13"/>

  <!--~
   ! The index of the lexer state that points to the first entry
   ! used for collecting action results.
  -->
  <xsl:variable name="p:result" as="xs:integer" select="14"/>

  <!--~
   ! The codepoint to charclass mapping for 7 bit codepoints.
  -->
  <xsl:variable name="p:MAP0" as="xs:integer+" select="
    55, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 6, 18, 19, 20, 21, 22, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 25, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 26, 6, 27, 6, 23, 6, 28, 29, 30, 31, 32, 33, 34, 35, 36, 23, 23, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 51, 52, 53, 6, 6
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints below the surrogate block.
  -->
  <xsl:variable name="p:MAP1" as="xs:integer+" select="
    108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214, 215, 213, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 331, 370, 386, 422, 422, 422, 414, 354, 346, 354, 346,
    354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 439, 439, 439, 439, 439, 439, 439, 315, 354, 354, 354, 354, 354, 354, 354,
    354, 400, 422, 422, 423, 421, 422, 422, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 422, 422, 422, 422,
    422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 353, 354, 354, 354,
    354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 55, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 17, 6, 18, 19, 20, 21, 22, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 6, 23, 23, 25, 23, 23, 23,
    23, 23, 23, 23, 23, 23, 26, 6, 27, 6, 23, 23, 23, 23, 23, 23, 23, 6, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 6, 28, 29, 30, 31, 32,
    33, 34, 35, 36, 23, 23, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 51, 52, 53, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 23, 23, 6, 6, 6, 6, 6,
    6, 6, 54, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints above the surrogate block.
  -->
  <xsl:variable name="p:MAP2" as="xs:integer+" select="
    57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 6, 23, 6, 23, 23, 6
  "/>

  <!--~
   ! The token-set-id to DFA-initial-state mapping.
  -->
  <xsl:variable name="p:INITIAL" as="xs:integer+" select="
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58
  "/>

  <!--~
   ! The DFA transition table.
  -->
  <xsl:variable name="p:TRANSITION" as="xs:integer+" select="
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 3586, 3584, 3584, 3602, 3631, 4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142,
    5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924,
    3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082,
    8002, 4253, 6089, 3631, 4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827,
    12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177,
    4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 6957, 4468, 4288, 4341, 4468, 3869, 4154, 4817, 4366, 3656, 5156, 3685,
    4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940,
    3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4382, 4468, 6079, 8526, 3631, 4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827,
    12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177,
    4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4398, 4467, 4451, 4485, 3631, 4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685,
    4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940,
    3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    10082, 4468, 4468, 8526, 3631, 4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096,
    3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128,
    4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 8521, 4468, 4514, 4550, 4468, 3869, 4154, 4817, 4575, 3656, 5156,
    3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942,
    3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4602, 4591, 4618, 4630, 4646, 4468, 3869, 4154, 3669, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096,
    3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128,
    4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 9354, 4671, 4679, 4695, 4729, 4468, 3869, 4154, 3769, 4780, 3656, 5156,
    3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942,
    3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 6118, 4527, 4534, 4754, 3631, 4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4796, 5157, 3686, 3702, 3742, 4037, 3785, 3984, 4043, 3872, 3809, 12096,
    3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128,
    4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 5123, 5132, 6199, 3631, 4468, 3869, 4154, 4817, 4780, 3656, 5156,
    3685, 4142, 5157, 3686, 4833, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942,
    3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 9448, 4873, 4881, 5234, 3631, 4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096,
    3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128,
    4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 5963, 5972, 6882, 11986, 4468, 5001, 8766, 8953, 4468, 10869,
    6395, 6395, 6562, 7682, 7682, 10264, 5192, 6395, 6395, 7758, 7682, 7683, 4897, 6395, 6395, 10775, 7682, 7665, 7177, 8723, 4913, 7441, 10534, 10775, 10010,
    6395, 7682, 8754, 7815, 6764, 4933, 4949, 4983, 5019, 8250, 10815, 7903, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 10082, 4468, 4468, 5054, 11986, 4468, 5001, 8766, 7841, 4468, 10869, 6395, 6395, 6562, 7682, 7682, 11867, 5192, 6395, 6395, 7758, 7682, 7683,
    4897, 6395, 6395, 10775, 7682, 7665, 6395, 8723, 7682, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 8250, 6464, 6459,
    8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 4468, 5113, 9435, 3631, 4468, 5148, 4154, 4817, 4780,
    3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888,
    3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 9193, 9185, 4468, 5173, 11986, 4468, 5001, 8766, 11252, 4468, 10869, 6395, 6395, 6562, 7682, 7682, 9323, 5192, 6395, 6395, 7758, 7682,
    10517, 5208, 6395, 6395, 10775, 7682, 7665, 6395, 8723, 7682, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 8250, 6464,
    6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 3615, 6170, 5224, 6144, 5250, 4468, 5584, 5333, 5801,
    4780, 5275, 5839, 5321, 5288, 5367, 5356, 5465, 5383, 5763, 5831, 5690, 5619, 5558, 3809, 5720, 5438, 5453, 5481, 5512, 5528, 5538, 5554, 5574, 5649, 5608,
    5635, 5679, 5792, 5496, 5592, 5706, 5736, 5752, 5398, 5305, 5300, 5340, 5663, 5779, 5817, 5855, 5871, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 10082, 6645, 6654, 6238, 5924, 4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872,
    3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112,
    4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 6928, 5953, 7211, 5988, 4468, 3869, 4154, 4817, 4780,
    3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888,
    3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 10082, 8134, 8143, 7977, 6027, 8849, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872,
    3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112,
    4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 4713, 4708, 6066, 3631, 4468, 3869, 4154, 4817, 4780,
    3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888,
    3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 10082, 4468, 4468, 6105, 3631, 4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872,
    3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112,
    4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 9477, 4655, 8024, 11986, 4468, 5001, 8766, 8027,
    4468, 6902, 6395, 6395, 9217, 7682, 7682, 7661, 10849, 6395, 6395, 10808, 7682, 7683, 4469, 6395, 6395, 10775, 7682, 7665, 6395, 8723, 7682, 11843, 6395,
    10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 8250, 6464, 6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 4468, 10082, 9477, 4655, 8024, 11986, 4468, 5001, 8766, 10300, 4468, 6902, 6395, 6395, 9217, 7682, 7682, 10132, 10849, 6395, 6395,
    10808, 7682, 7683, 4469, 6395, 6395, 10775, 7682, 7665, 6395, 8723, 7682, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722,
    8250, 6464, 6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 9477, 4738, 6134, 11986, 4468,
    5001, 8766, 8027, 4468, 6902, 6395, 6395, 9217, 7682, 7682, 7661, 10849, 6395, 6395, 10808, 7682, 7683, 4469, 6395, 6395, 10775, 7682, 7665, 6395, 8723,
    7682, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 8250, 6464, 6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 4468, 6160, 6186, 3631, 4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742,
    4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016,
    4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 8408, 8417, 4767, 3631,
    4468, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060,
    12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 9905, 10163, 10172, 6228, 11986, 9404, 6254, 6270, 6286, 4468, 6902, 6395, 6395, 9217, 7682, 7682,
    7661, 10108, 6395, 6395, 6340, 7682, 6438, 3640, 6374, 6394, 6412, 6434, 7132, 6395, 6454, 11476, 11843, 7321, 7488, 11925, 6481, 6534, 6555, 8724, 6764,
    8722, 6465, 7063, 8722, 8250, 6464, 6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 9477, 4655,
    8024, 11986, 4468, 5001, 8766, 8027, 4468, 6902, 6395, 6395, 9217, 7682, 7682, 7661, 10849, 6395, 6395, 10808, 7682, 7683, 4469, 6395, 6395, 10775, 7682,
    8915, 6578, 11389, 7682, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 11056, 6596, 6459, 8724, 8055, 8059, 7266, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 7727, 6622, 6635, 6670, 4468, 5001, 6706, 9816, 9896, 8550, 7600, 6395, 9534,
    11531, 7682, 7661, 10849, 6727, 11315, 11137, 10230, 6758, 4469, 6395, 9236, 10775, 11106, 7665, 6395, 8723, 7682, 8618, 7313, 6780, 10668, 8108, 8590,
    4996, 10372, 11734, 8722, 6465, 7063, 8722, 11907, 6835, 6459, 8724, 8055, 6518, 6869, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 10082, 8187, 8196, 6918, 11986, 6944, 7451, 8630, 8027, 7352, 6978, 6395, 7876, 11768, 7682, 10694, 7661, 10849, 6395, 6395, 10808, 7682, 7683, 4469,
    7014, 6395, 7035, 7682, 7665, 6395, 7058, 6711, 11843, 7079, 7096, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 7119, 7951, 7167, 6459, 8724,
    8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 4848, 4857, 7201, 11986, 7227, 10022, 7251, 7337, 7373,
    10064, 10981, 7392, 7611, 10291, 7428, 11191, 7467, 11710, 7504, 7520, 7544, 7572, 7627, 11692, 8100, 7643, 11292, 7665, 7406, 8723, 7681, 9760, 7806, 7699,
    9732, 7743, 7781, 7797, 7831, 7857, 10713, 4325, 11618, 8382, 7892, 7925, 7941, 8724, 9847, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 10082, 9477, 11995, 7967, 7993, 4468, 11551, 6819, 8027, 4468, 6902, 6395, 6395, 9217, 7682, 7682, 7661, 10849, 6395, 5003, 10808,
    7682, 10500, 4469, 6395, 6395, 10775, 7682, 8877, 6395, 8018, 9157, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 8250,
    6464, 6459, 8724, 8043, 8075, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 10425, 10434, 8124, 11986, 4468, 5001,
    8766, 8027, 4468, 6902, 6395, 6395, 9217, 7682, 7682, 7661, 10849, 6395, 6395, 10808, 7682, 7683, 4469, 6395, 6395, 10775, 7682, 7665, 6395, 8723, 7682,
    11843, 6395, 10775, 11925, 6395, 7682, 10346, 8159, 8212, 6511, 8246, 7063, 8722, 8250, 6464, 6459, 8724, 8701, 8266, 7266, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 9477, 4655, 8024, 8291, 4468, 8889, 8944, 8027, 8316, 6902, 6395, 6395, 8336, 7682, 10317, 7661, 10849,
    6395, 6395, 10808, 7682, 7683, 4469, 6395, 6395, 10775, 7682, 7665, 6395, 7481, 7682, 8364, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8230, 10704,
    7063, 8722, 8250, 6464, 6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4559, 10945, 10955, 8398,
    8433, 4468, 7144, 9860, 8027, 9957, 7279, 8449, 6395, 8465, 8493, 7682, 8542, 5884, 6395, 11227, 10808, 7682, 7654, 4469, 8566, 6395, 8585, 7682, 7665,
    7151, 8723, 4230, 9121, 6496, 8606, 8646, 11639, 9552, 4996, 8724, 6764, 8722, 6465, 7063, 8674, 8717, 6464, 6459, 8740, 8055, 8059, 8508, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 6002, 6011, 8787, 8813, 8848, 8222, 4219, 8027, 4468, 6902, 7412, 6395, 8865, 6418, 7682, 8911,
    10849, 8931, 6395, 11420, 5030, 7683, 4469, 6395, 6395, 10775, 7682, 7665, 6395, 8723, 7682, 8477, 6395, 8969, 11925, 6395, 7682, 8991, 10660, 11541, 8722,
    6465, 7063, 8722, 8250, 7765, 9014, 10255, 11164, 9030, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 6041, 6050,
    9055, 11986, 4468, 8374, 4314, 8027, 4468, 6902, 9090, 11701, 9109, 9155, 11000, 9173, 10849, 9209, 9233, 11368, 9252, 7683, 9289, 6845, 10206, 9305, 10580,
    7665, 6395, 8723, 7682, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 9273, 9339, 8722, 8250, 6464, 6459, 8724, 8055, 8059, 7266, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 6315, 6324, 9394, 9420, 9464, 9580, 9502, 9870, 4468, 6902, 6378, 6395, 9217, 8771,
    7682, 5038, 10849, 6395, 6395, 10808, 7682, 7683, 9486, 6395, 6992, 9550, 6350, 9568, 9614, 9643, 9659, 11843, 9706, 9724, 11925, 6807, 11663, 8089, 9748,
    9786, 8998, 7909, 8275, 9802, 9832, 7303, 6459, 8724, 8689, 8059, 7714, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 7357, 3717,
    3726, 9886, 11986, 6301, 8658, 9921, 9937, 4468, 6902, 6395, 8569, 9217, 7682, 4917, 7661, 5067, 6395, 6395, 9973, 7682, 10777, 4469, 9093, 6395, 11337,
    7682, 7665, 6395, 8723, 7682, 8348, 10199, 9997, 11925, 6395, 7682, 4996, 8724, 5097, 10457, 6358, 11918, 10038, 8250, 6464, 6459, 8724, 8055, 8059, 8174,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 9477, 5259, 10054, 11986, 4468, 5001, 8766, 8027, 4468, 6902, 9682, 4960,
    6606, 9315, 11083, 10841, 10849, 6395, 6395, 10808, 7682, 7683, 5937, 7019, 6395, 10631, 7682, 7665, 9708, 8723, 7103, 11843, 6395, 10775, 11925, 6395,
    7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 8250, 6464, 6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 10082, 9477, 4655, 8024, 11986, 10080, 9131, 7292, 8027, 4468, 6902, 6395, 6395, 9217, 7682, 7682, 7661, 10849, 6395, 6395, 10808, 7682, 7683, 4469,
    6395, 6395, 10775, 7682, 7665, 6395, 8723, 7682, 11843, 6395, 10775, 11925, 6395, 7682, 6794, 11823, 6764, 8722, 6465, 7063, 8722, 8250, 6464, 6459, 8724,
    8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 4074, 4083, 10098, 11986, 6212, 10608, 10124, 10148, 4468,
    7235, 8895, 11028, 9139, 8975, 6539, 7661, 10849, 10188, 6395, 11582, 10222, 7683, 4498, 6395, 10246, 10775, 10280, 7665, 6395, 8723, 7682, 11843, 6395,
    10775, 7528, 6395, 10316, 4996, 8724, 6764, 8722, 9981, 10333, 8722, 11816, 10362, 6459, 8724, 11152, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 4468, 10082, 5413, 5422, 10396, 11986, 10412, 9770, 10753, 8027, 6895, 4206, 10450, 10473, 6853, 10492, 10516, 7661, 10849, 6395,
    6395, 10808, 7682, 7683, 8300, 10533, 10550, 10576, 5908, 10596, 10476, 10624, 11500, 11843, 10647, 10684, 10729, 6395, 7682, 11382, 10769, 9516, 8722,
    11008, 9039, 8722, 11433, 6464, 10793, 10831, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 8320, 4413, 4428,
    4441, 11986, 10865, 10741, 9627, 8027, 11788, 10885, 6395, 10901, 9690, 7682, 10917, 7661, 4301, 10971, 11024, 11044, 11072, 11089, 6962, 6580, 7080, 10775,
    11105, 11122, 9598, 7185, 11180, 11207, 11223, 11243, 10380, 11268, 11284, 11308, 11331, 11353, 10560, 9673, 7063, 8722, 8250, 4237, 11405, 6742, 8055,
    8059, 10932, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 9369, 9378, 11449, 11986, 4468, 7867, 11895, 8027, 4468, 6902,
    6395, 6395, 9217, 7682, 7682, 7661, 7587, 9591, 6998, 10808, 11475, 5091, 4469, 6395, 6395, 10775, 7682, 7665, 6395, 8723, 7682, 7556, 6395, 11492, 11925,
    6395, 7682, 4996, 8724, 6764, 11516, 6465, 7063, 8722, 8250, 6464, 11567, 8724, 8055, 11609, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 10082, 9477, 4655, 8024, 11986, 4468, 9526, 5080, 8027, 5186, 6902, 11634, 6395, 9217, 11655, 7682, 7661, 11679, 6396, 6395, 10808, 7042,
    7683, 4469, 6395, 6395, 10775, 7682, 7665, 6395, 8723, 7682, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 8250, 6464,
    6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 9477, 4655, 8024, 11986, 4468, 5001, 11726,
    11955, 4468, 6902, 6395, 6395, 9217, 7682, 7682, 7661, 10849, 6395, 6395, 10808, 7682, 7683, 4469, 6395, 6395, 10775, 7682, 7665, 4967, 10991, 9265, 11750,
    6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 8250, 6464, 6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 10082, 9477, 4655, 8024, 11986, 11784, 11760, 5897, 8027, 4468, 6902, 6395, 6395, 11804, 7682, 7682, 11839, 10849, 6395,
    6395, 10808, 7682, 7683, 4469, 6395, 6395, 10775, 7682, 7665, 6395, 8723, 7682, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063,
    8722, 8250, 6464, 6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 9477, 4655, 8024, 11986,
    4468, 5001, 11859, 11593, 4468, 6902, 6395, 6395, 9217, 7682, 7682, 7661, 10849, 6395, 6395, 10808, 7682, 7683, 4469, 11883, 6395, 11941, 7682, 7665, 6395,
    8723, 7682, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 8250, 6464, 6459, 8724, 8055, 8059, 7266, 4468, 4468, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 7376, 11971, 9952, 8526, 3631, 4468, 12011, 4808, 4817, 4780, 12036, 5156, 3685, 3972, 5157, 3686,
    3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958,
    4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 8823, 8832,
    8797, 3631, 4350, 3869, 4154, 4817, 4780, 3656, 5156, 3685, 4142, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825,
    3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468,
    4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082, 9065, 9074, 11459, 3631, 4468, 3869, 4154, 4817, 4780, 12081, 5156, 3685, 3757,
    5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942, 3940, 3924,
    3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 10082,
    4468, 4468, 4468, 11986, 4468, 5001, 8766, 8027, 4468, 10869, 6395, 6395, 6562, 7682, 7682, 7661, 5192, 6395, 6395, 7758, 7682, 7683, 4469, 6395, 6395,
    10775, 7682, 7665, 6395, 8723, 7682, 11843, 6395, 10775, 11925, 6395, 7682, 4996, 8724, 6764, 8722, 6465, 7063, 8722, 8250, 6464, 6459, 8724, 8055, 8059,
    7266, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4263, 4272, 6690, 6681, 4468, 3869, 4154, 12020, 4780, 12036, 5156,
    3685, 3972, 5157, 3686, 3702, 3742, 4037, 3785, 4027, 4043, 3872, 3809, 12096, 3827, 12094, 3825, 3843, 12060, 12049, 12065, 3859, 3894, 3888, 3910, 3942,
    3940, 3924, 3793, 3958, 4000, 4016, 4059, 3871, 4154, 4161, 4112, 4099, 4128, 4177, 4193, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468, 4468,
    4468, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 68, 9275, 9275, 9275, 9275, 9275, 9275, 9275, 9275,
    9275, 9275, 9275, 9275, 0, 133120, 0, 0, 0, 0, 0, 0, 0, 62, 63, 0, 0, 0, 0, 0, 70, 0, 0, 0, 0, 68, 68, 68, 71, 72, 138240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    460, 0, 462, 462, 384, 0, 217088, 220160, 0, 0, 234496, 0, 0, 0, 0, 0, 0, 173, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 0, 133120, 180224,
    204800, 219136, 0, 142, 142, 0, 203776, 139264, 207872, 139264, 209920, 211968, 139264, 139264, 139264, 217088, 139264, 220160, 139264, 139264, 139264,
    139264, 139264, 139264, 139264, 139264, 139264, 234496, 139264, 139264, 139264, 134144, 0, 0, 0, 0, 178176, 188416, 0, 0, 0, 0, 73, 0, 0, 73, 73, 87, 87,
    87, 87, 87, 87, 87, 87, 87, 87, 111, 130, 111, 111, 111, 111, 0, 0, 0, 214016, 0, 0, 0, 0, 0, 0, 0, 139264, 0, 139264, 178176, 139264, 139264, 139264,
    139264, 139264, 234496, 139264, 139264, 139264, 0, 0, 327, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 0, 133120, 180224, 204800, 219136, 0, 68,
    272384, 272384, 139264, 139264, 139264, 210944, 212992, 214016, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 176128,
    139264, 183296, 139264, 139264, 139264, 139264, 199680, 135168, 233472, 0, 0, 191488, 0, 202752, 0, 0, 0, 0, 0, 0, 0, 182272, 137216, 139264, 202752,
    139264, 139264, 208896, 139264, 218112, 139264, 139264, 139264, 139264, 139264, 139264, 229376, 230400, 139264, 232448, 139264, 232448, 139264, 139264,
    139264, 0, 0, 0, 0, 0, 0, 237568, 0, 235520, 0, 139264, 179200, 139264, 235520, 139264, 237568, 0, 0, 195584, 0, 225280, 0, 0, 0, 139264, 139264, 139264,
    139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 0, 231424, 139264, 139264, 139264, 139264, 139264,
    139264, 139264, 139264, 139264, 195584, 139264, 139264, 139264, 139264, 139264, 221184, 139264, 139264, 225280, 139264, 139264, 221184, 139264, 139264,
    225280, 139264, 139264, 231424, 139264, 190464, 0, 0, 0, 0, 0, 139264, 139264, 0, 0, 0, 205824, 183296, 176128, 139264, 183296, 139264, 139264, 139264,
    139264, 199680, 205824, 139264, 139264, 139264, 185344, 139264, 139264, 190464, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264,
    139264, 139264, 205824, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 0, 206848, 226304, 139264, 181248, 139264, 139264, 139264, 139264,
    139264, 234496, 139264, 139264, 139264, 0, 0, 0, 139264, 139264, 139264, 139264, 139264, 0, 11264, 139264, 178176, 139264, 139264, 139264, 139264, 139264,
    139264, 188416, 139264, 196608, 206848, 215040, 222208, 139264, 226304, 139264, 139264, 139264, 139264, 181248, 139264, 139264, 139264, 196608, 206848,
    215040, 222208, 139264, 226304, 139264, 139264, 139264, 0, 139264, 186368, 139264, 139264, 139264, 139264, 139264, 0, 0, 139264, 178176, 139264, 139264,
    139264, 139264, 139264, 139264, 188416, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 198656, 139264, 139264, 139264, 139264, 139264, 210944,
    212992, 214016, 139264, 139264, 139264, 236544, 139264, 186368, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 236544, 0, 0, 0, 0, 73, 0,
    0, 73, 73, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 113, 132, 113, 113, 113, 113, 139264, 192512, 139264, 216064, 139264, 139264, 139264, 228352, 139264,
    139264, 192512, 139264, 216064, 139264, 139264, 139264, 139264, 139264, 139264, 189440, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 228352,
    139264, 228352, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 177152, 139264, 139264, 139264, 139264,
    139264, 234496, 139264, 139264, 139264, 0, 0, 220, 139264, 139264, 139264, 139264, 0, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264,
    139264, 139264, 139264, 0, 139264, 139264, 189440, 139264, 139264, 139264, 139264, 139264, 227328, 177152, 139264, 139264, 139264, 139264, 227328, 139264,
    197632, 223232, 139264, 139264, 197632, 223232, 139264, 187392, 139264, 187392, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 224256, 224256, 0,
    0, 0, 0, 0, 0, 0, 280, 0, 282, 283, 284, 173, 99, 99, 99, 99, 0, 118, 118, 118, 118, 118, 230, 118, 118, 118, 118, 118, 118, 557, 118, 118, 118, 118, 118,
    118, 118, 118, 118, 767, 99, 99, 99, 99, 99, 99, 76, 13388, 13388, 13388, 13388, 13388, 13388, 13388, 13388, 13388, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12288, 12288,
    12288, 12288, 12288, 12288, 12288, 12288, 12288, 12288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 71, 71, 71, 71, 71, 71, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 0, 380, 0,
    382, 383, 284, 384, 99, 99, 99, 99, 0, 118, 118, 118, 118, 118, 231, 118, 118, 118, 118, 118, 118, 702, 118, 0, 99, 99, 99, 708, 99, 99, 99, 0, 0, 0, 68,
    68, 68, 5265, 72, 138240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109568, 0, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 193536, 0, 200704, 201728, 0, 0, 207872, 209920,
    211968, 0, 15360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 15360, 0, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 0, 0, 0, 73, 0, 0, 73, 73, 90, 90, 94,
    90, 94, 90, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 115, 134, 115, 115, 115, 115, 134, 134, 134, 134, 134, 134, 134, 0, 0, 0, 0, 0, 0, 0, 0, 16384, 0, 0, 0,
    0, 0, 16384, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 0, 0, 0, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 0, 0, 133120, 0, 0, 0,
    0, 0, 0, 0, 456, 457, 0, 0, 0, 0, 0, 0, 384, 0, 0, 0, 72, 72, 72, 72, 72, 72, 72, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 0, 20480, 20480, 20480, 20480, 20480,
    20480, 20480, 20480, 20480, 20480, 0, 11381, 0, 20480, 0, 0, 0, 0, 0, 68, 68, 68, 71, 5266, 138240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 0, 0, 0, 68, 0, 0, 72,
    0, 0, 0, 0, 0, 193536, 0, 200704, 201728, 0, 0, 207872, 209920, 211968, 60, 60, 60, 60, 60, 60, 60, 17468, 17468, 60, 60, 60, 60, 60, 17468, 60, 60, 60, 60,
    60, 60, 60, 60, 60, 60, 69, 17468, 60, 60, 17468, 60, 60, 17468, 17468, 17468, 17468, 17468, 60, 60, 17468, 60, 17468, 17468, 17468, 17468, 17468, 17468,
    17468, 17468, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 142, 142, 142, 71, 72, 138240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 118, 99, 99, 99, 99, 19456, 19456, 19456, 0,
    19456, 19456, 19456, 0, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 0, 0, 0, 0, 0, 19456, 0, 19456, 19456, 0, 0, 0, 19456, 0, 0,
    19456, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40960, 0, 40960, 40960, 0, 0, 0, 68, 68, 29696, 71, 72, 138240, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 100, 119, 100, 100, 100, 100, 20480, 20480, 20480, 11381, 11381, 11381, 11381, 11381, 11381, 11381, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 0, 44032,
    0, 44032, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 0, 193536, 0, 200704, 201728, 0, 0, 207872, 209920, 211968, 139264, 139264, 139264, 139264, 139264, 234496,
    139264, 139264, 139264, 0, 11264, 220, 139264, 139264, 139264, 139264, 0, 139264, 139484, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264,
    139264, 0, 133120, 180224, 204800, 219136, 0, 68, 68, 0, 139264, 139264, 139264, 139264, 234496, 139264, 139264, 139264, 134144, 368, 0, 0, 0, 178176,
    188416, 0, 0, 0, 0, 73, 0, 74, 73, 73, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 104, 123, 104, 104, 104, 104, 0, 22528, 0, 0, 0, 22528, 0, 0, 22528, 22528,
    22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 118, 118, 554, 118, 118,
    118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 357, 118, 118, 118, 99, 686, 99, 687, 688, 99, 99, 99, 99, 99, 118, 118, 118, 118, 118, 697, 118,
    698, 699, 118, 118, 118, 118, 118, 0, 99, 706, 99, 99, 99, 99, 99, 99, 309, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 534, 99, 99, 99, 99, 99, 712, 99, 99,
    99, 118, 716, 118, 118, 118, 118, 118, 722, 118, 118, 118, 0, 0, 0, 0, 0, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 412, 99, 726, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 736, 118, 118, 118, 118, 118, 118, 432, 118, 118, 118, 118, 118, 118, 118, 118, 118, 0, 0, 370, 0, 0, 0, 0, 0, 0, 0, 0, 24712,
    24712, 24712, 24712, 24712, 24712, 24712, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 379, 0, 0, 0, 0, 284, 384, 99, 99, 99, 99, 0, 118, 118, 118, 118, 118, 233, 118,
    118, 118, 118, 118, 443, 118, 118, 118, 118, 118, 118, 118, 118, 118, 0, 0, 0, 682, 99, 99, 99, 0, 26722, 26722, 26722, 26722, 26722, 26722, 26722, 26722,
    26722, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 0, 0, 0, 0, 0, 0, 0, 27648, 139264, 139264, 139264,
    139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 193536, 139264, 139264, 139264, 139264, 200704, 201728, 139264,
    203776, 0, 0, 0, 137, 137, 137, 137, 137, 137, 137, 0, 0, 61, 0, 0, 0, 0, 0, 271, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 284, 0, 99, 99, 99, 369, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 28672, 28672, 28672, 28734, 28672, 28672, 28734, 28672, 28672, 28734, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 0, 0, 133120, 0, 0,
    0, 0, 0, 0, 143, 18576, 143, 71, 72, 138240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 131, 112, 112, 112, 112, 0, 217088, 220160, 0, 0, 234496, 0, 0, 0, 0, 0, 0,
    173, 139436, 139436, 139436, 139436, 139436, 234668, 139436, 139436, 139436, 0, 0, 220, 139483, 139483, 139483, 139483, 0, 139436, 139436, 139436, 139436,
    139436, 139436, 139436, 139436, 139436, 139436, 139483, 139483, 139483, 139483, 139483, 139483, 203948, 139436, 208044, 139436, 210092, 212140, 139436,
    139436, 139436, 217260, 139436, 220332, 139436, 139436, 139436, 139436, 218, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 139483,
    139483, 0, 139436, 139436, 189612, 139436, 139436, 139436, 139483, 208091, 139483, 210139, 212187, 139483, 139483, 139483, 217307, 139483, 220379, 139483,
    139483, 139483, 139483, 139483, 139483, 139483, 193755, 139483, 139483, 139483, 139483, 200923, 201947, 139483, 203995, 0, 0, 0, 214016, 0, 0, 0, 0, 0, 0,
    0, 139264, 0, 139436, 178348, 139436, 139436, 139436, 236716, 139483, 186587, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 236763, 0, 0,
    0, 0, 73, 0, 75, 73, 73, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 114, 133, 114, 114, 114, 114, 139436, 139436, 209068, 139436, 218284, 139436, 139436,
    139436, 139436, 139436, 139436, 229548, 230572, 139436, 232620, 139436, 139436, 139483, 139483, 139483, 182491, 139483, 139483, 139483, 139483, 139483,
    191707, 139483, 139483, 139483, 139483, 234715, 139483, 139483, 139483, 134144, 0, 0, 0, 0, 178176, 188416, 0, 139483, 202971, 139483, 139483, 209115,
    139483, 218331, 139483, 139483, 139483, 139483, 139483, 139483, 229595, 230619, 139483, 139483, 0, 0, 0, 205824, 183296, 176300, 139436, 183468, 139436,
    139436, 139436, 139436, 199852, 205996, 232667, 139483, 139483, 139483, 0, 0, 0, 0, 0, 0, 237568, 0, 235520, 0, 139436, 179372, 139436, 139436, 184492,
    139436, 139436, 139436, 139436, 139436, 194732, 139436, 139436, 139436, 139436, 139436, 139436, 139436, 235692, 139436, 237740, 139483, 179419, 139483,
    139483, 184539, 139483, 139483, 139483, 139483, 139483, 194779, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 139483,
    139483, 139483, 139483, 139483, 0, 139483, 235739, 139483, 237787, 0, 0, 195584, 0, 225280, 0, 0, 0, 139436, 139436, 139436, 139436, 139436, 139436, 139436,
    139436, 139436, 139436, 139436, 139436, 139436, 139436, 176347, 139483, 183515, 139483, 139483, 139483, 139483, 199899, 231596, 139436, 139483, 139483,
    139483, 139483, 139483, 139483, 139483, 139483, 195803, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 198875, 139483, 139483, 139483, 139483,
    139483, 211163, 213211, 214235, 221403, 139483, 139483, 225499, 139483, 139483, 231643, 139483, 190464, 0, 0, 0, 0, 0, 139436, 139436, 139436, 139436,
    195756, 139436, 139436, 139436, 139436, 139436, 221356, 139436, 139436, 225452, 139436, 139436, 139436, 139436, 139483, 139483, 189659, 139483, 139483,
    139483, 139483, 139483, 139483, 139483, 228352, 139436, 139436, 185516, 139436, 139436, 190636, 139436, 139436, 139436, 139436, 139436, 139436, 139436,
    139436, 139436, 139436, 139436, 0, 0, 139483, 178395, 139483, 139483, 139483, 139483, 139483, 139483, 188635, 206043, 139483, 139483, 139483, 139483,
    139483, 139483, 139483, 139483, 0, 206848, 226304, 139436, 181420, 139436, 139436, 139436, 182444, 139436, 139436, 139436, 139436, 139436, 191660, 139436,
    139436, 139436, 139436, 139436, 202924, 139436, 196780, 207020, 215212, 222380, 139436, 226476, 139436, 139436, 139436, 139483, 181467, 139483, 139483,
    139483, 196827, 207067, 215259, 222427, 139483, 226523, 139483, 139483, 139483, 0, 139436, 186540, 139436, 139436, 139436, 139436, 139436, 188588, 139436,
    139436, 139436, 139436, 139436, 139436, 139436, 198828, 139436, 139436, 139436, 192684, 139436, 216236, 139436, 139436, 139436, 228524, 139483, 139483,
    192731, 139483, 216283, 139483, 139483, 139483, 185563, 139483, 139483, 190683, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 139483, 0,
    133120, 180224, 204800, 219136, 0, 272528, 143, 0, 228571, 139436, 139436, 139436, 139436, 139436, 139436, 139483, 139483, 139483, 139483, 139483, 139483,
    177324, 139436, 139436, 139436, 211116, 213164, 214188, 139436, 139436, 139436, 139436, 139436, 139436, 139436, 139436, 139436, 139436, 193708, 139436,
    139436, 139436, 139436, 200876, 201900, 139436, 139436, 139436, 227500, 177371, 139483, 139483, 139483, 139483, 227547, 139436, 197804, 223404, 139436,
    139483, 197851, 223451, 139483, 187564, 139436, 187611, 139483, 139436, 139483, 139436, 139483, 139436, 139483, 224428, 224475, 0, 0, 0, 0, 0, 378, 0, 0, 0,
    0, 0, 284, 384, 99, 99, 99, 99, 0, 118, 118, 118, 118, 118, 234, 118, 118, 118, 118, 118, 506, 118, 118, 118, 118, 118, 511, 118, 118, 118, 118, 0, 0, 0,
    68, 68, 68, 71, 72, 138240, 0, 0, 0, 33792, 0, 0, 0, 0, 0, 455, 0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 35936, 35936, 35936, 35936, 35936, 35936, 35936, 35936,
    35936, 35936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 68, 68, 71,
    72, 138240, 0, 0, 14336, 34816, 38912, 0, 0, 0, 0, 73, 0, 0, 73, 73, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 108, 127, 108, 108, 108, 108, 0, 0, 0, 68, 68,
    68, 71, 72, 138240, 0, 0, 0, 0, 39936, 0, 0, 0, 0, 73, 0, 0, 73, 73, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 109, 128, 109, 109, 109, 109, 0, 0, 0, 40960,
    40960, 40960, 40960, 40960, 40960, 40960, 0, 0, 133120, 0, 0, 0, 0, 0, 15360, 0, 0, 15360, 15360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13388, 0, 0, 133120, 0, 0, 0,
    0, 0, 0, 41984, 41984, 41984, 41984, 41984, 41984, 41984, 0, 0, 133120, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 100, 100, 100, 119, 119, 119,
    119, 119, 119, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28672, 0, 18432, 133120, 30720, 0, 0, 0, 43008, 43008, 43008, 43008, 43008, 43008, 43008, 43008, 43008, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 28672, 28672, 28672, 28672, 28672, 28672, 28672, 0, 0, 0, 43008, 43008, 43008, 43008, 43008, 43008, 43008, 0, 0, 133120, 0, 0, 0, 0, 0,
    21504, 21504, 21504, 21504, 21504, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 169, 0, 0, 101, 101, 101, 120, 120, 120, 120, 120, 120, 120, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 32845, 0, 0, 133120, 0, 0, 0, 171, 0, 99, 99, 99, 177, 99, 99, 99, 99, 99, 99, 199, 201, 99, 205, 99, 208, 99, 99, 0, 118, 118, 118,
    224, 118, 118, 118, 118, 118, 118, 246, 248, 118, 252, 118, 255, 118, 118, 0, 0, 0, 0, 0, 0, 68, 68, 0, 0, 0, 0, 161, 0, 0, 0, 0, 166, 0, 0, 0, 166, 0, 0,
    0, 0, 73, 0, 0, 73, 73, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 110, 129, 110, 110, 110, 110, 99, 99, 416, 99, 99, 11590, 384, 118, 118, 420, 118, 118, 118,
    118, 118, 118, 118, 507, 118, 118, 118, 118, 118, 118, 118, 118, 0, 99, 99, 707, 99, 99, 99, 99, 99, 99, 99, 466, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 303, 99, 99, 99, 477, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 400, 99, 99, 118, 118, 118, 493, 118, 118, 118, 118, 118, 118,
    118, 118, 118, 118, 343, 118, 118, 118, 118, 118, 118, 118, 504, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 450, 118, 118, 0, 99, 99,
    99, 99, 544, 99, 99, 99, 99, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 0, 99, 99, 99, 99, 99, 99, 99, 99, 99, 619, 99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 630, 99, 99, 99, 99, 99, 583, 99, 99, 99, 99, 99, 588, 99, 99, 590, 99, 99, 99, 99, 99, 689, 99, 99, 99, 99, 118, 118, 118, 118, 118, 118, 99,
    99, 99, 819, 118, 118, 118, 118, 118, 118, 118, 636, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 355, 118, 118, 118, 118, 647, 118, 0, 0, 0, 0,
    0, 99, 99, 99, 99, 99, 99, 99, 99, 99, 0, 0, 220, 118, 118, 118, 118, 526, 527, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 476, 99, 118, 118,
    118, 761, 118, 763, 118, 765, 118, 0, 99, 99, 99, 99, 99, 99, 99, 324, 99, 11590, 284, 220, 118, 118, 118, 118, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 102,
    121, 102, 102, 102, 102, 121, 121, 121, 121, 121, 121, 121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32845, 32845, 32845, 32845, 32845, 32845, 32845, 32845, 32845, 32845,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 68, 68, 71, 72, 73, 0, 148, 0, 0, 0, 0, 0, 0, 0, 0, 138240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12288, 0, 0, 133120, 0, 0, 0, 99, 209,
    99, 99, 0, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 562, 118, 118, 118, 118, 99, 99, 99, 99, 391, 99, 99, 99, 99, 99, 99, 99, 99, 99, 399, 99,
    99, 99, 99, 99, 790, 791, 99, 118, 118, 118, 118, 118, 118, 796, 797, 118, 118, 118, 441, 442, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 0, 0, 0,
    99, 99, 99, 99, 99, 99, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 603, 118, 118, 0, 0, 0, 0, 0, 99, 99, 99, 99, 99, 657, 99, 99, 99, 99, 99,
    99, 622, 623, 99, 99, 99, 627, 99, 99, 99, 99, 0, 118, 118, 118, 118, 118, 118, 118, 118, 240, 118, 118, 118, 118, 760, 118, 118, 118, 118, 118, 118, 0, 99,
    99, 99, 99, 99, 99, 99, 470, 99, 99, 99, 99, 99, 99, 99, 99, 99, 11590, 284, 220, 118, 118, 118, 332, 821, 99, 99, 118, 118, 99, 118, 99, 118, 99, 118, 99,
    118, 0, 0, 0, 0, 0, 23552, 23552, 23552, 23552, 23552, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 284, 173, 99, 99, 99, 103, 103,
    103, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35840, 35840, 35840, 35840, 35840, 35840, 35840, 0, 0, 156, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    156, 0, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 461, 0, 0, 384, 276, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 284, 173, 287, 99, 99, 99, 99, 99, 480, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99, 99, 409, 99, 99, 99, 99, 99, 99, 99, 99, 467, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 474, 99, 99, 99, 99, 99, 118,
    118, 118, 118, 494, 118, 118, 118, 118, 118, 118, 118, 118, 118, 434, 118, 118, 118, 118, 118, 118, 540, 99, 99, 99, 99, 99, 99, 99, 99, 118, 118, 118, 118,
    118, 118, 118, 118, 118, 118, 118, 0, 579, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 487, 99, 99, 118, 118, 118, 118, 597, 118, 118, 118,
    118, 118, 118, 118, 118, 118, 560, 118, 118, 118, 118, 118, 118, 99, 99, 728, 99, 99, 99, 99, 99, 99, 99, 118, 118, 738, 118, 118, 118, 118, 0, 518, 0, 0,
    0, 0, 0, 0, 0, 0, 99, 99, 99, 99, 181, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 535, 99, 99, 99, 99, 118, 118, 118, 118, 762, 118, 118, 118, 118, 0, 99,
    99, 99, 99, 99, 99, 99, 532, 99, 99, 99, 99, 99, 99, 99, 99, 99, 547, 118, 118, 118, 118, 118, 118, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 35936, 0, 0, 133120, 0, 31744, 0, 0, 154, 0, 159, 0, 162, 0, 164, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 284, 173, 99, 288, 99, 207, 210,
    213, 99, 0, 118, 118, 118, 118, 227, 118, 118, 237, 118, 244, 118, 99, 99, 118, 118, 99, 118, 99, 118, 99, 118, 99, 118, 0, 0, 0, 0, 0, 0, 279, 0, 0, 0, 0,
    284, 173, 99, 99, 99, 99, 0, 118, 118, 118, 118, 118, 232, 118, 118, 118, 118, 118, 118, 764, 118, 766, 0, 99, 99, 99, 99, 99, 99, 99, 585, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 587, 99, 99, 99, 99, 99, 99, 249, 118, 118, 254, 257, 260, 118, 0, 266, 0, 0, 0, 267, 68, 68, 0, 0, 0, 0, 270, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 66, 0, 0, 68, 0, 0, 0, 268, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107520, 68, 0, 99, 99, 99, 307, 99, 99, 99, 99, 99, 99, 99, 99, 99, 314, 99, 99,
    99, 99, 99, 530, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 301, 99, 99, 99, 99, 118, 118, 349, 118, 118, 118, 118, 118, 118, 118, 118, 118, 356, 118, 118,
    118, 118, 0, 570, 0, 0, 0, 0, 0, 0, 99, 99, 99, 99, 99, 99, 99, 99, 192, 99, 99, 99, 99, 99, 374, 0, 376, 0, 0, 0, 0, 0, 0, 0, 0, 284, 384, 385, 99, 99, 99,
    99, 99, 545, 99, 99, 99, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 605, 99, 402, 99, 99, 99, 99, 404, 405, 406, 99, 99, 99, 99, 411,
    99, 413, 99, 99, 99, 417, 99, 11590, 384, 419, 118, 118, 118, 118, 118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 616, 99, 118, 118, 428, 118, 118, 431, 118, 118,
    118, 118, 118, 436, 118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 0, 0, 99, 576, 99, 99, 438, 439, 440, 118, 118, 118, 118, 445, 118, 447, 118, 118, 118, 451, 118,
    0, 0, 0, 0, 377, 0, 0, 0, 0, 0, 0, 284, 384, 99, 99, 99, 99, 99, 295, 99, 99, 99, 99, 300, 99, 99, 99, 99, 99, 99, 323, 99, 99, 11590, 284, 220, 118, 118,
    118, 118, 0, 0, 453, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 99, 99, 118, 118, 118, 118, 118, 495, 496, 118, 498, 118, 118, 118, 118, 118, 118, 444, 118,
    118, 118, 118, 118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 99, 552, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,
    118, 0, 99, 99, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 604, 118, 99, 99, 118, 118, 99, 118, 99, 118, 828, 829, 99, 118, 0, 0, 0, 0, 73,
    0, 0, 73, 73, 0, 0, 0, 0, 95, 0, 95, 618, 99, 99, 99, 99, 621, 99, 99, 624, 99, 99, 99, 99, 629, 631, 99, 99, 99, 99, 99, 11590, 0, 118, 118, 118, 118, 118,
    118, 118, 118, 118, 0, 99, 99, 99, 99, 771, 99, 118, 118, 635, 118, 118, 118, 118, 638, 118, 118, 641, 118, 118, 118, 118, 646, 648, 118, 0, 0, 0, 0, 0, 99,
    654, 99, 99, 99, 99, 99, 99, 99, 99, 586, 99, 99, 99, 99, 99, 99, 99, 99, 667, 118, 118, 118, 670, 118, 118, 118, 99, 660, 99, 99, 99, 99, 99, 99, 118, 668,
    118, 118, 118, 118, 118, 118, 118, 25600, 133385, 0, 0, 0, 0, 68, 68, 0, 118, 118, 674, 118, 118, 118, 118, 118, 118, 681, 0, 0, 99, 99, 99, 99, 99, 99,
    189, 99, 99, 99, 99, 99, 99, 99, 310, 99, 99, 312, 99, 99, 99, 99, 99, 118, 118, 118, 745, 0, 99, 99, 749, 99, 99, 99, 99, 99, 99, 99, 118, 778, 118, 118,
    118, 118, 118, 118, 118, 118, 0, 99, 99, 99, 99, 99, 710, 99, 118, 759, 118, 118, 118, 118, 118, 118, 118, 0, 768, 99, 99, 770, 99, 772, 99, 99, 99, 99,
    777, 118, 118, 779, 118, 781, 118, 118, 118, 118, 0, 99, 99, 99, 99, 99, 752, 99, 99, 99, 99, 118, 105, 105, 105, 124, 124, 124, 124, 124, 124, 124, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 37966, 0, 0, 133120, 0, 0, 0, 0, 140, 0, 68, 68, 68, 71, 72, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 76, 76, 76, 76, 76, 76, 76, 99, 99, 99,
    543, 99, 99, 99, 99, 99, 118, 118, 118, 118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 68, 68, 0, 118, 798, 99, 99, 99, 99, 99, 804, 118, 118, 118, 118, 118, 99, 99,
    99, 99, 99, 99, 118, 118, 118, 118, 118, 118, 99, 99, 99, 99, 118, 118, 118, 99, 99, 99, 118, 118, 118, 118, 118, 118, 818, 99, 99, 99, 820, 118, 118, 0, 0,
    0, 0, 0, 99, 99, 99, 655, 99, 99, 99, 99, 99, 99, 481, 482, 99, 99, 99, 99, 99, 99, 99, 99, 99, 625, 626, 99, 99, 99, 99, 99, 106, 106, 106, 125, 125, 125,
    125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37966, 37966, 37966, 37966, 37966, 37966, 37966, 37966, 37966, 37966, 0, 0, 0, 0, 0, 0, 99, 99, 661, 99, 99,
    99, 99, 99, 118, 118, 118, 118, 118, 118, 672, 118, 99, 99, 118, 118, 99, 118, 826, 827, 99, 118, 99, 118, 0, 0, 0, 0, 73, 0, 0, 73, 73, 80, 80, 80, 80, 80,
    80, 80, 80, 80, 80, 103, 122, 103, 103, 103, 103, 118, 118, 118, 675, 118, 118, 118, 118, 118, 0, 0, 0, 99, 99, 99, 99, 99, 183, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 692, 118, 118, 118, 118, 118, 118, 118, 118, 118, 700, 118, 118, 118, 118, 0, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 118, 812, 99, 99, 118, 118,
    815, 816, 118, 118, 99, 99, 99, 99, 118, 118, 118, 118, 118, 720, 118, 118, 118, 118, 118, 0, 0, 0, 141, 68, 68, 68, 71, 72, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    458, 0, 0, 0, 0, 0, 384, 0, 0, 0, 269, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 68, 0, 318, 99, 99, 99, 99, 99, 99, 99, 99, 11590, 284, 220, 118, 118,
    118, 118, 0, 0, 0, 0, 0, 0, 0, 0, 575, 99, 99, 99, 567, 118, 118, 118, 0, 0, 0, 0, 0, 0, 0, 0, 99, 99, 99, 99, 99, 184, 99, 99, 99, 99, 99, 99, 99, 99, 99,
    735, 118, 118, 118, 118, 118, 118, 107, 107, 107, 126, 126, 126, 126, 126, 126, 126, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44032, 44032, 44032, 44032, 44032, 44032,
    44032, 44032, 44032, 44032, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 68, 68, 71, 72, 73, 0, 0, 0, 0, 0, 0, 150, 99, 291, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 304, 99, 99, 99, 321, 99, 99, 99, 99, 325, 11590, 284, 220, 118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 0, 574, 99, 99, 577, 99, 333, 118, 118, 118, 118,
    118, 118, 118, 118, 118, 118, 118, 118, 118, 346, 118, 99, 99, 118, 118, 824, 825, 99, 118, 99, 118, 99, 118, 0, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 133120, 0, 0, 0, 118, 118, 363, 118, 118, 118, 118, 367, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 284, 173, 286, 99, 99, 99, 99, 465, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 315, 99, 99, 99, 99, 118, 118, 492, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 642, 643, 118, 118, 118, 99, 592,
    118, 118, 118, 118, 118, 118, 118, 118, 118, 601, 118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 573, 0, 99, 99, 99, 99, 0, 118, 118, 118, 118, 118, 118, 118, 118,
    239, 118, 118, 118, 606, 118, 118, 608, 118, 118, 610, 0, 0, 0, 0, 0, 0, 99, 99, 99, 179, 182, 99, 188, 99, 99, 99, 200, 203, 99, 99, 99, 99, 99, 99, 730,
    99, 732, 733, 734, 99, 118, 118, 118, 118, 740, 118, 99, 99, 800, 801, 99, 99, 118, 118, 806, 807, 118, 118, 99, 99, 99, 99, 99, 99, 118, 118, 118, 118,
    118, 118, 99, 99, 811, 742, 743, 744, 118, 0, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 118, 118, 118, 118, 118, 118, 118, 118, 99, 99, 788, 99, 789, 99, 99,
    99, 118, 118, 118, 794, 118, 795, 118, 118, 0, 0, 0, 0, 0, 653, 99, 99, 99, 656, 99, 99, 99, 99, 0, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,
    345, 118, 118, 118, 118, 108, 108, 108, 127, 127, 127, 127, 127, 127, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108636, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 68, 68, 68,
    71, 72, 73, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108636, 108636, 108636, 108636, 108636, 108636, 108636, 108636, 108636, 108636, 0, 0, 0, 0, 0, 0, 151, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36864, 99, 319, 99, 99, 99, 99, 99, 99, 99, 11590, 284, 220, 118, 118, 118, 118, 0, 0, 0, 0, 0, 522, 0, 0, 0, 0, 99, 99,
    99, 178, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 302, 99, 99, 99, 99, 361, 118, 118, 118, 118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 0, 0, 0, 524, 99, 99,
    99, 99, 389, 99, 99, 99, 99, 99, 99, 99, 99, 99, 398, 99, 99, 99, 99, 0, 118, 118, 118, 225, 118, 118, 118, 118, 118, 118, 118, 0, 133120, 0, 0, 0, 0, 68,
    68, 0, 99, 99, 118, 118, 595, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 344, 118, 118, 118, 118, 118, 118, 118, 650, 0, 0, 0, 0, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 118, 118, 118, 695, 118, 118, 773, 99, 99, 99, 118, 118, 118, 118, 780, 118, 782, 118, 118, 118, 0, 786, 99, 99, 99, 118, 814,
    118, 118, 118, 118, 99, 99, 99, 99, 118, 118, 118, 118, 719, 118, 721, 118, 118, 118, 118, 0, 109, 109, 109, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 110592, 110592, 110592, 110592, 110592, 110592, 110592, 110592, 110592, 110592, 0, 0, 0, 0, 0, 0, 99, 99, 292, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 475, 99, 99, 99, 99, 320, 99, 99, 99, 99, 99, 99, 11590, 284, 220, 118, 118, 118, 118, 0, 0, 0, 0, 0, 572, 0, 0, 99, 99, 99, 99, 99,
    185, 99, 99, 99, 99, 99, 99, 99, 99, 99, 11590, 284, 220, 118, 330, 118, 118, 118, 334, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,
    118, 565, 118, 118, 362, 118, 118, 118, 118, 118, 118, 0, 0, 0, 371, 0, 0, 0, 0, 0, 0, 0, 61, 61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 99, 99, 99,
    390, 99, 99, 99, 393, 99, 99, 99, 99, 99, 99, 99, 99, 99, 11590, 284, 220, 118, 118, 118, 118, 99, 99, 403, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
    99, 486, 99, 99, 118, 427, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 437, 118, 118, 118, 118, 118, 556, 118, 118, 118, 118, 118, 118, 118, 118, 118,
    118, 704, 99, 99, 99, 99, 99, 99, 99, 0, 0, 0, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 99, 99, 118, 118, 118, 118, 118, 118, 118, 497, 118, 118, 118,
    118, 118, 118, 340, 118, 118, 118, 118, 118, 118, 118, 118, 118, 265, 369, 0, 0, 0, 0, 0, 0, 99, 99, 714, 99, 118, 118, 118, 118, 118, 118, 118, 118, 118,
    724, 118, 0, 0, 0, 0, 19456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 0, 0, 0, 73, 0, 0, 73, 73, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 116, 135, 116, 116, 116,
    116, 110, 110, 110, 129, 129, 129, 129, 129, 129, 129, 0, 0, 0, 0, 0, 0, 0, 0, 165, 0, 0, 0, 0, 0, 170, 0, 139, 0, 0, 68, 68, 68, 71, 72, 73, 0, 0, 0, 0, 0,
    149, 0, 0, 0, 0, 26722, 26722, 26722, 26722, 26722, 0, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 22528, 0, 0, 0, 0, 0, 0, 0, 68, 0, 0, 0, 157, 0, 0, 0, 0, 0, 0, 0,
    167, 0, 168, 0, 0, 0, 0, 73, 0, 0, 73, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 459, 0, 0, 0, 0, 384, 99, 99, 99, 217, 0, 118, 118, 221, 118, 118, 118, 118, 118,
    241, 118, 118, 118, 118, 118, 677, 118, 118, 118, 0, 0, 0, 99, 99, 99, 99, 99, 186, 99, 99, 99, 99, 99, 99, 99, 99, 99, 11590, 284, 220, 328, 118, 118, 118,
    99, 489, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 645, 118, 118, 118, 118, 516, 517, 0, 0, 0, 521, 0, 0, 523, 0, 0, 99, 99,
    174, 99, 99, 99, 99, 99, 194, 99, 99, 99, 99, 99, 99, 392, 99, 99, 99, 99, 99, 99, 99, 99, 99, 533, 99, 99, 99, 99, 99, 539, 99, 99, 99, 528, 529, 99, 531,
    99, 99, 99, 99, 99, 536, 99, 99, 99, 99, 0, 118, 118, 223, 118, 118, 118, 118, 238, 243, 245, 118, 99, 99, 542, 99, 99, 99, 99, 99, 99, 118, 118, 118, 118,
    118, 550, 551, 118, 553, 118, 118, 118, 118, 118, 558, 118, 118, 118, 118, 118, 564, 118, 118, 118, 118, 118, 701, 118, 118, 0, 99, 99, 99, 99, 99, 99, 99,
    298, 99, 99, 99, 99, 99, 99, 99, 99, 99, 11590, 284, 220, 118, 118, 331, 118, 99, 580, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 538, 99, 99,
    99, 118, 118, 118, 118, 118, 598, 118, 118, 118, 118, 118, 118, 118, 118, 0, 611, 0, 613, 614, 615, 99, 99, 99, 99, 99, 662, 99, 99, 99, 99, 118, 118, 118,
    669, 118, 118, 118, 118, 0, 0, 0, 571, 0, 0, 0, 0, 99, 99, 99, 99, 99, 99, 99, 99, 195, 99, 99, 99, 99, 99, 118, 118, 118, 118, 676, 118, 118, 118, 118, 0,
    0, 0, 99, 99, 99, 684, 99, 99, 99, 729, 99, 99, 99, 99, 99, 99, 118, 118, 118, 739, 118, 118, 118, 118, 256, 118, 118, 0, 0, 0, 0, 0, 0, 68, 68, 0, 118,
    118, 118, 118, 746, 99, 99, 99, 99, 99, 99, 99, 754, 99, 756, 118, 99, 799, 99, 99, 99, 803, 118, 805, 118, 118, 118, 809, 99, 99, 99, 99, 0, 118, 118, 118,
    118, 228, 118, 118, 118, 118, 118, 118, 264, 0, 0, 0, 0, 0, 0, 68, 68, 0, 111, 111, 111, 130, 130, 130, 130, 130, 130, 130, 0, 0, 0, 0, 0, 0, 0, 0, 273, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 68, 0, 99, 211, 214, 99, 0, 118, 118, 118, 226, 229, 118, 235, 118, 118, 118, 247, 250, 118, 118, 118, 258, 261,
    118, 0, 0, 0, 0, 0, 0, 68, 68, 0, 0, 0, 0, 107520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 274, 0, 0, 0, 0, 99, 99, 99, 99, 418, 11590, 384, 118, 118, 118, 118,
    118, 118, 118, 118, 118, 0, 705, 99, 99, 99, 99, 99, 99, 99, 99, 593, 118, 118, 118, 118, 118, 118, 118, 118, 118, 602, 118, 118, 118, 118, 118, 609, 118,
    118, 0, 0, 0, 0, 0, 0, 99, 99, 99, 99, 180, 99, 99, 190, 99, 197, 99, 202, 99, 99, 99, 727, 99, 99, 99, 731, 99, 99, 99, 99, 118, 737, 118, 118, 118, 741,
    112, 112, 112, 131, 131, 131, 131, 131, 131, 131, 0, 0, 0, 0, 0, 0, 0, 0, 281, 0, 0, 284, 173, 99, 99, 99, 152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    68, 0, 113, 113, 113, 132, 132, 132, 132, 132, 132, 132, 0, 0, 0, 0, 0, 0, 0, 0, 381, 0, 0, 284, 384, 99, 99, 386, 99, 99, 215, 99, 0, 118, 118, 222, 118,
    118, 118, 118, 118, 118, 118, 118, 266, 0, 0, 0, 0, 0, 0, 0, 118, 251, 253, 118, 118, 262, 118, 0, 0, 0, 0, 0, 0, 68, 68, 0, 0, 0, 64, 73, 64, 0, 73, 73,
    79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 101, 120, 101, 101, 101, 101, 387, 99, 99, 99, 99, 99, 99, 99, 99, 99, 396, 99, 99, 99, 99, 99, 99, 584, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 485, 99, 99, 99, 99, 99, 118, 118, 118, 118, 430, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 433, 118, 118, 118,
    118, 118, 118, 118, 99, 478, 99, 99, 99, 99, 99, 99, 483, 99, 99, 99, 99, 99, 99, 99, 99, 792, 118, 118, 118, 118, 118, 118, 118, 118, 134144, 368, 0, 0, 0,
    0, 0, 0, 118, 118, 118, 505, 118, 118, 118, 118, 118, 118, 510, 118, 118, 118, 118, 118, 338, 118, 118, 341, 118, 118, 118, 118, 118, 118, 118, 0, 266, 0,
    0, 0, 0, 68, 68, 0, 633, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 360, 99, 713, 99, 99, 715, 118, 118, 118, 118, 118, 118,
    118, 723, 118, 118, 0, 0, 0, 0, 0, 99, 99, 99, 99, 99, 99, 658, 99, 99, 758, 118, 118, 118, 118, 118, 118, 118, 118, 0, 99, 99, 99, 99, 99, 99, 99, 666,
    118, 118, 118, 118, 118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 99, 617, 114, 114, 114, 133, 133, 133, 133, 133, 133, 133, 0, 0, 0, 0, 0, 138, 0, 0, 158, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 158, 0, 0, 0, 0, 73, 0, 0, 73, 73, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 106, 125, 106, 106, 106, 106, 290, 99, 99, 293, 99, 99, 297,
    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 693, 118, 118, 118, 118, 118, 99, 305, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 537, 99, 99, 118,
    118, 335, 118, 118, 339, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 446, 118, 118, 118, 118, 118, 118, 0, 347, 118, 118, 118, 118, 118, 118, 118,
    118, 118, 118, 118, 118, 118, 118, 118, 369, 463, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 591, 99, 99, 99, 479, 99, 99, 99, 99, 99, 484,
    99, 99, 99, 99, 99, 99, 99, 690, 99, 99, 118, 118, 694, 118, 118, 118, 488, 99, 490, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 512,
    118, 118, 118, 118, 118, 515, 118, 0, 0, 0, 520, 0, 0, 0, 0, 0, 0, 99, 99, 175, 99, 99, 99, 99, 99, 99, 99, 99, 99, 204, 206, 99, 541, 99, 99, 99, 99, 99,
    99, 99, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 501, 118, 99, 99, 99, 582, 99, 99, 99, 99, 99, 99, 99, 99, 589, 99, 99, 99, 99, 99, 99,
    665, 99, 118, 118, 118, 118, 118, 118, 118, 118, 0, 0, 612, 0, 0, 0, 99, 99, 99, 99, 118, 118, 118, 118, 118, 118, 118, 600, 118, 118, 118, 118, 118, 118,
    352, 118, 118, 354, 118, 118, 118, 118, 118, 118, 118, 703, 0, 99, 99, 99, 99, 99, 99, 99, 99, 691, 99, 118, 118, 118, 118, 118, 118, 118, 118, 607, 118,
    118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 99, 99, 176, 99, 99, 99, 99, 191, 196, 198, 99, 99, 99, 99, 0, 118, 118, 118, 118, 118, 118, 118, 118, 242, 118, 118,
    99, 99, 99, 99, 663, 99, 99, 99, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 452, 0, 99, 774, 99, 99, 118, 118, 118, 118, 118,
    118, 118, 783, 118, 118, 0, 99, 99, 99, 99, 99, 11590, 384, 118, 118, 118, 118, 118, 118, 118, 118, 118, 0, 99, 769, 99, 99, 99, 99, 787, 99, 99, 99, 99,
    99, 99, 99, 118, 793, 118, 118, 118, 118, 118, 118, 366, 118, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 284, 384, 99, 99, 99, 0, 155, 0, 160, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 173, 99, 99, 99, 0, 0, 0, 277, 278, 0, 0, 275, 0, 0, 0, 284, 173, 99, 99, 289, 99, 306, 99, 99, 308, 99, 99, 99, 99, 99, 99, 99, 99, 99, 316,
    317, 348, 118, 118, 350, 118, 118, 118, 118, 118, 118, 118, 118, 118, 358, 359, 118, 99, 822, 118, 823, 99, 118, 99, 118, 99, 118, 99, 118, 0, 0, 0, 0, 73,
    0, 0, 73, 73, 83, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 107, 126, 107, 107, 107, 107, 99, 388, 99, 99, 99, 99, 99, 99, 99, 395, 99, 99, 99, 99, 99, 99,
    296, 99, 99, 299, 99, 99, 99, 99, 99, 99, 99, 546, 99, 118, 118, 118, 118, 118, 118, 118, 353, 118, 118, 118, 118, 118, 118, 118, 118, 0, 99, 99, 99, 99,
    709, 99, 711, 401, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 313, 99, 99, 99, 414, 415, 99, 99, 99, 11590, 384, 118, 118, 118, 118, 422,
    118, 118, 118, 118, 0, 99, 99, 99, 99, 751, 99, 753, 99, 755, 99, 118, 118, 118, 118, 429, 118, 118, 118, 118, 118, 118, 435, 118, 118, 118, 118, 118, 351,
    118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 448, 449, 118, 118, 118, 0, 503, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,
    118, 513, 118, 514, 118, 118, 0, 0, 519, 0, 0, 0, 0, 0, 0, 0, 525, 99, 99, 99, 99, 99, 11590, 384, 118, 118, 118, 118, 118, 118, 118, 425, 118, 99, 99, 99,
    99, 802, 99, 118, 118, 118, 118, 808, 118, 99, 99, 99, 99, 99, 99, 118, 118, 118, 118, 118, 118, 99, 810, 99, 118, 118, 118, 118, 555, 118, 118, 118, 118,
    118, 561, 118, 118, 118, 118, 118, 365, 118, 118, 266, 0, 0, 0, 372, 0, 0, 373, 118, 118, 118, 118, 569, 0, 0, 0, 0, 0, 0, 0, 99, 99, 99, 578, 99, 99, 581,
    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 410, 99, 99, 99, 99, 99, 118, 118, 118, 596, 118, 118, 599, 118, 118, 118, 118, 118, 118, 118, 265, 137,
    0, 0, 0, 0, 68, 68, 0, 99, 99, 99, 620, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 632, 118, 634, 118, 118, 118, 637, 118, 118, 118, 118, 118, 118, 118,
    118, 118, 118, 508, 509, 118, 118, 118, 118, 118, 118, 118, 649, 0, 651, 0, 0, 0, 99, 99, 99, 99, 99, 99, 99, 99, 99, 407, 408, 99, 99, 99, 99, 99, 659, 99,
    99, 99, 99, 664, 99, 99, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 502, 118, 673, 118, 118, 118, 118, 678, 118, 118, 0, 0, 0, 99, 99,
    683, 99, 99, 99, 99, 99, 11590, 384, 118, 118, 118, 118, 118, 118, 424, 118, 118, 0, 0, 652, 0, 0, 99, 99, 99, 99, 99, 99, 99, 99, 99, 118, 118, 548, 549,
    118, 118, 118, 99, 99, 99, 776, 118, 118, 118, 118, 118, 118, 118, 118, 118, 785, 0, 99, 99, 99, 99, 99, 11590, 384, 118, 118, 118, 118, 118, 423, 118, 118,
    118, 118, 0, 747, 99, 99, 99, 99, 99, 99, 99, 99, 99, 757, 116, 116, 116, 135, 135, 135, 135, 135, 135, 135, 0, 0, 0, 0, 0, 0, 0, 0, 110592, 110592, 0, 0,
    133120, 0, 0, 0, 426, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 566, 99, 99, 118, 594, 118, 118, 118, 118, 118, 118, 118,
    118, 118, 118, 118, 118, 559, 118, 118, 118, 563, 118, 118, 118, 685, 99, 99, 99, 99, 99, 99, 99, 99, 99, 118, 118, 118, 118, 696, 118, 118, 118, 118, 337,
    118, 118, 118, 118, 342, 118, 118, 118, 118, 118, 118, 118, 679, 118, 0, 0, 0, 99, 99, 99, 99, 99, 99, 99, 99, 193, 99, 99, 99, 99, 99, 99, 99, 775, 99,
    118, 118, 118, 118, 118, 118, 118, 118, 784, 118, 0, 99, 99, 99, 99, 99, 11590, 384, 118, 118, 118, 421, 118, 118, 118, 118, 118, 263, 118, 0, 0, 0, 0, 0,
    0, 68, 68, 0, 99, 813, 99, 118, 118, 118, 118, 817, 118, 99, 99, 99, 99, 118, 118, 118, 718, 118, 118, 118, 118, 118, 118, 118, 725, 99, 99, 99, 99, 294,
    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 628, 99, 99, 99, 118, 118, 118, 336, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 639, 640,
    118, 118, 118, 644, 118, 118, 0, 375, 0, 0, 0, 0, 0, 0, 0, 0, 0, 284, 384, 99, 99, 99, 99, 99, 468, 469, 99, 471, 99, 99, 99, 99, 99, 99, 99, 99, 311, 99,
    99, 99, 99, 99, 99, 99, 99, 394, 99, 99, 397, 99, 99, 99, 99, 99, 212, 99, 99, 0, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 680, 0, 0, 0, 99,
    99, 99, 99, 118, 118, 568, 118, 0, 0, 0, 0, 0, 0, 0, 0, 99, 99, 99, 99, 99, 187, 99, 99, 99, 99, 99, 99, 99, 99, 99, 11590, 284, 220, 329, 118, 118, 118,
    153, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 275, 0, 0, 0, 99, 99, 99, 99, 322, 99, 99, 99, 99, 11590, 284, 220, 118, 118, 118, 118, 0, 99, 748, 99,
    99, 99, 99, 99, 99, 99, 99, 118, 118, 118, 118, 118, 671, 118, 118, 118, 118, 118, 364, 118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 0, 0, 99, 99, 99, 99, 99, 99,
    216, 99, 0, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 134144, 0, 0, 0, 0, 0, 0, 0, 99, 464, 99, 99, 99, 99, 99, 99, 99, 99, 472, 473, 99, 99,
    99, 99, 0, 118, 118, 118, 118, 118, 118, 236, 118, 118, 118, 118, 0, 99, 99, 99, 750, 99, 99, 99, 99, 99, 99, 118, 118, 717, 118, 118, 118, 118, 118, 118,
    118, 118, 0, 0, 0, 0, 0, 0, 99, 99, 99, 99, 118, 491, 118, 118, 118, 118, 118, 118, 118, 118, 499, 500, 118, 118, 118, 118, 259, 118, 118, 0, 0, 0, 0, 0, 0,
    68, 68, 0, 0, 0, 0, 107520, 0, 0, 0, 0, 0, 0, 0, 0, 107520, 0, 107520, 0, 0, 0, 68, 68, 68, 71, 72, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 105, 124, 105, 105,
    105, 105, 0, 0, 139264, 139437, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 0, 133120, 180224, 204800,
    219136, 0, 0, 0, 0, 0, 217088, 220160, 0, 0, 234496, 0, 0, 0, 0, 0, 0, 0, 139264, 139264, 139264, 139264, 139264, 139264, 235520, 139264, 237568, 139264,
    179200, 139264, 139264, 184320, 139264, 139264, 139264, 139264, 139264, 194560, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264,
    139264, 139264, 139264, 0, 217088, 220160, 0, 0, 234496, 0, 0, 0, 0, 0, 0, 285, 139264, 139264, 139264, 139264, 139264, 182272, 139264, 139264, 139264,
    139264, 139264, 191488, 139264, 139264, 139264, 139264, 139264, 202752
  "/>

  <!--~
   ! The DFA-state to expected-token-set mapping.
  -->
  <xsl:variable name="p:EXPECTED" as="xs:integer+" select="
    208, 212, 216, 220, 224, 247, 231, 236, 242, 246, 562, 232, 232, 252, 278, 278, 261, 562, 232, 232, 259, 278, 279, 691, 232, 232, 277, 278, 255, 232, 291,
    278, 294, 232, 277, 238, 232, 278, 265, 267, 272, 275, 283, 268, 275, 284, 288, 297, 267, 301, 302, 306, 310, 314, 318, 322, 326, 680, 330, 466, 336, 340,
    527, 346, 247, 414, 353, 247, 426, 543, 359, 247, 504, 397, 520, 372, 376, 478, 546, 247, 385, 396, 389, 378, 393, 402, 409, 406, 418, 424, 430, 420, 577,
    443, 437, 447, 454, 494, 440, 450, 491, 501, 473, 477, 412, 482, 485, 488, 227, 511, 498, 368, 433, 508, 519, 598, 524, 247, 660, 530, 536, 555, 349, 540,
    247, 550, 532, 554, 591, 560, 571, 566, 575, 581, 248, 585, 589, 595, 703, 569, 608, 602, 469, 606, 612, 616, 620, 625, 632, 621, 636, 628, 639, 643, 647,
    651, 657, 664, 668, 672, 247, 678, 653, 355, 684, 556, 247, 247, 332, 247, 247, 342, 674, 247, 247, 362, 247, 247, 689, 695, 247, 700, 247, 365, 695, 685,
    247, 463, 247, 460, 696, 247, 381, 513, 379, 398, 247, 515, 380, 457, 247, 247, 247, 247, 247, 247, 247, 227, 707, 711, 715, 717, 721, 725, 729, 731, 735,
    739, 743, 747, 751, 755, 758, 762, 992, 773, 1273, 765, 764, 1136, 1004, 785, 888, 888, 888, 888, 888, 1028, 789, 789, 765, 886, 789, 794, 798, 803, 775,
    765, 765, 765, 765, 766, 888, 888, 1250, 789, 765, 765, 886, 888, 1239, 789, 789, 815, 765, 893, 885, 888, 888, 789, 789, 892, 789, 789, 894, 888, 888, 890,
    789, 789, 789, 789, 790, 789, 789, 887, 888, 889, 789, 789, 1243, 888, 888, 891, 789, 765, 765, 888, 789, 789, 1242, 1036, 889, 789, 1036, 891, 1031, 1034,
    1034, 894, 765, 1133, 765, 885, 821, 1214, 1217, 829, 831, 835, 838, 838, 842, 846, 765, 1135, 765, 1199, 854, 858, 899, 904, 765, 765, 768, 1247, 765,
    1133, 765, 1198, 825, 910, 765, 765, 769, 1078, 971, 808, 905, 765, 767, 1065, 1069, 972, 809, 765, 765, 799, 1229, 970, 930, 811, 765, 767, 1077, 765, 768,
    1078, 765, 861, 1016, 1021, 936, 765, 1011, 1207, 917, 929, 810, 765, 765, 765, 882, 765, 765, 947, 765, 1263, 923, 765, 1206, 924, 942, 947, 765, 955, 941,
    932, 765, 765, 765, 881, 962, 765, 765, 1081, 765, 1200, 1263, 968, 960, 905, 765, 869, 765, 765, 850, 917, 943, 765, 765, 966, 979, 765, 941, 981, 765,
    765, 824, 937, 1262, 956, 980, 765, 869, 765, 1224, 765, 1142, 879, 765, 874, 878, 765, 874, 978, 905, 1143, 880, 765, 876, 880, 765, 986, 880, 874, 878,
    765, 883, 765, 765, 895, 884, 765, 895, 1078, 765, 900, 905, 765, 766, 1119, 1123, 990, 1130, 1130, 1130, 991, 765, 765, 765, 1081, 911, 996, 996, 996,
    1000, 1000, 1000, 765, 867, 765, 985, 765, 875, 879, 765, 877, 860, 1015, 1020, 765, 990, 875, 765, 921, 917, 928, 817, 1025, 1040, 1008, 1046, 765, 765,
    884, 765, 765, 882, 1044, 765, 765, 765, 1198, 1071, 1089, 1102, 765, 1011, 849, 916, 1090, 1103, 765, 765, 1224, 765, 1223, 906, 806, 1097, 1101, 905, 765,
    1011, 1082, 915, 941, 931, 905, 1075, 1067, 1086, 1099, 1257, 872, 765, 765, 765, 1233, 1100, 1104, 765, 765, 885, 1236, 1098, 1102, 765, 1222, 951, 765,
    765, 1171, 1094, 1108, 872, 765, 765, 976, 980, 765, 1118, 1150, 1259, 1119, 1099, 1260, 1222, 1108, 873, 765, 766, 1065, 1096, 1119, 1099, 1260, 765, 1050,
    1055, 1060, 1170, 1120, 1127, 950, 764, 765, 1118, 1122, 1261, 765, 1112, 1140, 766, 1121, 1111, 765, 1147, 1123, 1113, 766, 780, 764, 778, 777, 1154, 1224,
    777, 1154, 764, 779, 1154, 765, 779, 1160, 1159, 765, 779, 763, 778, 1155, 1164, 1169, 781, 1164, 1169, 781, 1165, 1165, 1175, 1177, 1178, 765, 765, 1228,
    765, 817, 873, 871, 765, 1051, 1056, 1061, 1182, 1184, 1187, 1186, 1191, 1192, 1192, 1193, 1197, 765, 1204, 765, 765, 1254, 1211, 1221, 765, 765, 1262, 865,
    817, 765, 765, 765, 1267, 1075, 1079, 816, 765, 765, 906, 1254, 765, 765, 765, 1271, 766, 1076, 1080, 765, 1117, 1149, 1101, 131330, 147712, 164096, 196864,
    393472, 655616, 2228480, 537002240, 1073873152, 131328, 131328, 131328, 268567040, 213248, 426240, 2490624, 393472, 131328, 393552, 2490624, 393472, 721218,
    3080514, -2004997888, -2004997888, -2004997888, -2004932352, -2004997888, -2004997888, -1904330496, -1904264960, -1367459584, -1904330496, -1904248576,
    -1367394048, -1904264960, -1904215808, -1367377664, 131488, 132512, 197024, 655776, 229792, 459168, 721312, 917920, 983456, 25396670, 126059966, 131302846,
    131564990, 131302846, -1980252738, 256, 131072, 2, 536870912, 1073741824, 0, 0, 0, 0, 1, 2, 4, 16, 131584, 268435968, 16, 16, 0, 0, 1, 262144, 33554432,
    67108864, 536870912, 0, 0, 67108864, 128, 160, 1152, 1152, 1152, 1152, 8, 1152, 1152, 1152, 16777228, 14, 0, 0, 0, 3, 0, 512, 512, 512, 65536, 134217728,
    268435456, 536870912, 1073741824, -2147483648, 0, 0, 12, 8, 0, 0, 0, 8, 32768, 0, 32768, 33554432, 0, 8192, 8388608, 67108864, 1417946359, 1418077311,
    1418077823, 1418077823, 1418077823, 1418077823, 1418077951, 1418077823, 1418077823, -34816, -34816, -34816, -34816, -33920, -33920, -33920, -33920, -32896,
    -33920, -32769, 0, 0, 14336, 16384, 65536, 0, 3, 96, 8192, 8388608, 1409286144, 0, 0, 7, 24, 3936, 8, 393216, 0, 0, 128, 2097152, 0, 0, 256, 0, 0, 0, 4096,
    4194304, 16777216, 134217728, 0, 0, 0, 64, 0, 0, 0, 128, 128, 128, 128, 1152, 1152, 1152, 0, 0, 0, 2, 0, 96256, 1966080, 31457280, 2113929216, 2113929216,
    -2147483648, 0, 0, 0, 32, 268435456, 1073741824, 0, 0, 407459384, 16384, 65536, 393216, 524288, 1048576, 6291456, 6144, 8192, 16384, 65536, 262144, 524288,
    1048576, 8388608, 16777216, 33554432, 67108864, 134217728, 536870912, 1073741824, -2147483648, 0, 67108864, 1073741824, 0, 0, 1048576, 6291456, 16777216,
    33554432, 134217728, -2147483648, 0, 33554432, 0, 1073741824, 512, 268435456, 256, 0, 262144, 6144, 65536, 262144, 6291456, 16777216, 33554432, 134217728,
    1073741824, -2147483648, 0, 0, 6144, 65536, 262144, 1048576, 6291456, 8388608, 16777216, 100663296, 134217728, 0, 4096, 65536, 6291456, 16777216, 134217728,
    -2147483648, 0, 0, 0, 4096, 4194304, 134217728, 0, 4096, 4194304, 0, 0, 0, 512, 407459640, 407459640, 407459640, 407459640, -2097281, -2097281, -2097281,
    -2097281, 1568, 20480, 65536, 524288, 4194304, 134217728, 268435456, 0, 0, 262144, 393216, 3936, 28672, 98304, 1966080, 4194304, 4194304, 125829120,
    134217728, -268435456, 0, 16, 32, 512, 1024, 1152, 1184, 1152, 128, 128, 1152, 128, 1152, 128, 128, 128, 4096, 16384, 65536, 524288, 0, 768, 0, 0, 1824, 0,
    0, 3, 4, 8, 16, 16, 32, 64, 768, 1024, 1024, 2048, 12288, 16384, 32768, 4, 32, 256, 512, 2048, 8192, 32768, 65536, 393216, 524288, 1, 2, 4, 32, 64, 128, 0,
    0, 0, 6144, 8192, 32768, 65536, 393216, 1048576, 4194304, 8388608, 117440512, 134217728, 256, 512, 2048, 393216, 1048576, 8388608, 50331648, 67108864,
    134217728, 268435456, 1610612736, -2147483648, 0, 0, 0, 512, 134217728, 268435456, 536870912, 1073741824, 0, 1073741824, 0, 0, 1, 4, 256, 512, 393216,
    50331648, 67108864, 268435456, 536870912, 67108864, 268435456, 1610612736, 0, 0, 4194304, 0, 0, 32768, 0, 0, 0, 24, 512, 268435456, 0, 0, 4096, 6291456,
    16777216, 0, 1, 512, 393216, 8388608, 50331648, 67108864, 33554432, 67108864, 536870912, 1073741824, 0, 67108864, 536870912, 1073741824, 1073741824, 0, 0,
    1, 33554432, 67108864, 0, 536870912, 0, 0, 1, 4, 32, 67108864, 0, 67108864, 67108864, 67108864, 67108864, 0, 3728, 3728, 3760, 3984, 3760, 3760, 3760, 3760,
    4016, 3760, 247, 247, 247, 247, 2295, 3831, 0, 0, 0, 33554432, 0, 0, 0, 8, 0, 0, 6144, 16384, 65536, 16, 128, 1024, 0, 0, 1417684087, 1417684087,
    1417684215, 1417946231, 1417684215, 48, 0, 0, 0, 1073741824, 0, 0, 3, 116, 128, 0, 0, 16, 128, 0, 32, 128, 128, 128, 1024, 1056, 1152, 1152, 0, 128, 128,
    16, 32, 64, 128, 1024, 1152, 1056, 0, 128, 0, 32, 512, 134217728, 268435456, 1610612736, 0, 0, 0, 262144, 6144, 2, 32, 64, 128, 0, 2, 64, 0, 0, 8192
  "/>

  <!--~
   ! The token-string table.
  -->
  <xsl:variable name="p:TOKEN" as="xs:string+" select="
    '(0)',
    'IntegerLiteral',
    'DecimalLiteral',
    'DoubleLiteral',
    'StringLiteral',
    'URIQualifiedName',
    'NCName',
    'QName',
    'S',
    'CommentContents',
    'Wildcard',
    'EOF',
    &quot;'!'&quot;,
    &quot;'!='&quot;,
    &quot;'#'&quot;,
    &quot;'$'&quot;,
    &quot;'('&quot;,
    &quot;'(:'&quot;,
    &quot;')'&quot;,
    &quot;'*'&quot;,
    &quot;'+'&quot;,
    &quot;','&quot;,
    &quot;'-'&quot;,
    &quot;'.'&quot;,
    &quot;'..'&quot;,
    &quot;'/'&quot;,
    &quot;'//'&quot;,
    &quot;':'&quot;,
    &quot;':)'&quot;,
    &quot;'::'&quot;,
    &quot;':='&quot;,
    &quot;'&lt;'&quot;,
    &quot;'&lt;&lt;'&quot;,
    &quot;'&lt;='&quot;,
    &quot;'='&quot;,
    &quot;'=&gt;'&quot;,
    &quot;'&gt;'&quot;,
    &quot;'&gt;='&quot;,
    &quot;'&gt;&gt;'&quot;,
    &quot;'?'&quot;,
    &quot;'@'&quot;,
    &quot;'['&quot;,
    &quot;']'&quot;,
    &quot;'ancestor'&quot;,
    &quot;'ancestor-or-self'&quot;,
    &quot;'and'&quot;,
    &quot;'array'&quot;,
    &quot;'as'&quot;,
    &quot;'attribute'&quot;,
    &quot;'cast'&quot;,
    &quot;'castable'&quot;,
    &quot;'child'&quot;,
    &quot;'comment'&quot;,
    &quot;'descendant'&quot;,
    &quot;'descendant-or-self'&quot;,
    &quot;'div'&quot;,
    &quot;'document-node'&quot;,
    &quot;'element'&quot;,
    &quot;'else'&quot;,
    &quot;'empty-sequence'&quot;,
    &quot;'eq'&quot;,
    &quot;'every'&quot;,
    &quot;'except'&quot;,
    &quot;'following'&quot;,
    &quot;'following-sibling'&quot;,
    &quot;'for'&quot;,
    &quot;'function'&quot;,
    &quot;'ge'&quot;,
    &quot;'gt'&quot;,
    &quot;'idiv'&quot;,
    &quot;'if'&quot;,
    &quot;'in'&quot;,
    &quot;'instance'&quot;,
    &quot;'intersect'&quot;,
    &quot;'is'&quot;,
    &quot;'item'&quot;,
    &quot;'le'&quot;,
    &quot;'let'&quot;,
    &quot;'lt'&quot;,
    &quot;'map'&quot;,
    &quot;'mod'&quot;,
    &quot;'namespace'&quot;,
    &quot;'namespace-node'&quot;,
    &quot;'ne'&quot;,
    &quot;'node'&quot;,
    &quot;'of'&quot;,
    &quot;'or'&quot;,
    &quot;'parent'&quot;,
    &quot;'preceding'&quot;,
    &quot;'preceding-sibling'&quot;,
    &quot;'processing-instruction'&quot;,
    &quot;'return'&quot;,
    &quot;'satisfies'&quot;,
    &quot;'schema-attribute'&quot;,
    &quot;'schema-element'&quot;,
    &quot;'self'&quot;,
    &quot;'some'&quot;,
    &quot;'switch'&quot;,
    &quot;'text'&quot;,
    &quot;'then'&quot;,
    &quot;'to'&quot;,
    &quot;'treat'&quot;,
    &quot;'typeswitch'&quot;,
    &quot;'union'&quot;,
    &quot;'{'&quot;,
    &quot;'|'&quot;,
    &quot;'||'&quot;,
    &quot;'}'&quot;
  "/>

  <!--~
   ! Match next token in input string, starting at given index, using
   ! the DFA entry state for the set of tokens that are expected in
   ! the current context.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start in input string.
   ! @param $token-set the expected token set id.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:match" as="xs:integer+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="result" select="$p:INITIAL[1 + $token-set]"/>
    <xsl:sequence select="p:transition($input, $begin, $begin, $begin, $result, $result mod 1024, 0)"/>
  </xsl:function>

  <!--~
   ! The DFA state transition function. If we are in a valid DFA state, save
   ! it's result annotation, consume one input codepoint, calculate the next
   ! state, and use tail recursion to do the same again. Otherwise, return
   ! any valid result or a negative DFA state id in case of an error.
   !
   ! @param $input the input string.
   ! @param $begin the begin index of the current token in the input string.
   ! @param $current the index of the current position in the input string.
   ! @param $end the end index of the result in the input string.
   ! @param $result the result code.
   ! @param $current-state the current DFA state.
   ! @param $previous-state the  previous DFA state.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:transition">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="current" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>
    <xsl:param name="result" as="xs:integer"/>
    <xsl:param name="current-state" as="xs:integer"/>
    <xsl:param name="previous-state" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$current-state eq 0">
        <xsl:variable name="result" select="$result idiv 1024"/>
        <xsl:variable name="end" select="$end - $result idiv 128"/>
        <xsl:variable name="end" select="if ($end gt string-length($input)) then string-length($input) + 1 else $end"/>
        <xsl:sequence select="
          if ($result ne 0) then
          (
            $result mod 128 - 1,
            $begin,
            $end
          )
          else
          (
            - $previous-state,
            $begin,
            $current - 1
          )
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="c0" select="(string-to-codepoints(substring($input, $current, 1)), 0)[1]"/>
        <xsl:variable name="c1" as="xs:integer">
          <xsl:choose>
            <xsl:when test="$c0 &lt; 128">
              <xsl:sequence select="$p:MAP0[1 + $c0]"/>
            </xsl:when>
            <xsl:when test="$c0 &lt; 55296">
              <xsl:variable name="c1" select="$c0 idiv 16"/>
              <xsl:variable name="c2" select="$c1 idiv 32"/>
              <xsl:sequence select="$p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="p:map2($c0, 1, 6)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="current" select="$current + 1"/>
        <xsl:variable name="i0" select="1024 * $c1 + $current-state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 16"/>
        <xsl:variable name="next-state" select="$p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]"/>
        <xsl:sequence select="
          if ($next-state &gt; 1023) then
            p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
          else
            p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Recursively translate one 32-bit chunk of an expected token bitset
   ! to the corresponding sequence of token strings.
   !
   ! @param $result the result of previous recursion levels.
   ! @param $chunk the 32-bit chunk of the expected token bitset.
   ! @param $base-token-code the token code of bit 0 in the current chunk.
   ! @return the set of token strings.
  -->
  <xsl:function name="p:token">
    <xsl:param name="result" as="xs:string*"/>
    <xsl:param name="chunk" as="xs:integer"/>
    <xsl:param name="base-token-code" as="xs:integer"/>

    <xsl:sequence select="
      if ($chunk = 0) then
        $result
      else
        p:token
        (
          ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
          if ($chunk &lt; 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
          $base-token-code + 1
        )
    "/>
  </xsl:function>

  <!--~
   ! Calculate expected token set for a given DFA state as a sequence
   ! of strings.
   !
   ! @param $state the DFA state.
   ! @return the set of token strings
  -->
  <xsl:function name="p:expected-token-set" as="xs:string*">
    <xsl:param name="state" as="xs:integer"/>

    <xsl:if test="$state > 0">
      <xsl:for-each select="0 to 3">
        <xsl:variable name="i0" select=". * 829 + $state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 4"/>
        <xsl:variable name="i2" select="$i1 idiv 4"/>
        <xsl:sequence select="p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], . * 32 + 1)"/>
      </xsl:for-each>
    </xsl:if>
  </xsl:function>

  <!--~
   ! Classify codepoint by doing a tail recursive binary search for a
   ! matching codepoint range entry in MAP2, the codepoint to charclass
   ! map for codepoints above the surrogate block.
   !
   ! @param $c the codepoint.
   ! @param $lo the binary search lower bound map index.
   ! @param $hi the binary search upper bound map index.
   ! @return the character class.
  -->
  <xsl:function name="p:map2" as="xs:integer">
    <xsl:param name="c" as="xs:integer"/>
    <xsl:param name="lo" as="xs:integer"/>
    <xsl:param name="hi" as="xs:integer"/>

    <xsl:variable name="m" select="($hi + $lo) idiv 2"/>
    <xsl:choose>
      <xsl:when test="$lo &gt; $hi">
        <xsl:sequence select="0"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[$m] &gt; $c">
        <xsl:sequence select="p:map2($c, $lo, $m - 1)"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[6 + $m] &lt; $c">
        <xsl:sequence select="p:map2($c, $m + 1, $hi)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$p:MAP2[12 + $m]"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing the 1st loop of production Comment (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Comment-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(14, $input, $state)"/>      <!-- CommentContents | ('(' ':') | (':' ')') -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] = 28">                                      <!-- (':' ')') -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 9">                                 <!-- CommentContents -->
                  <xsl:variable name="state" select="p:consumeT(9, $input, $state)"/> <!-- CommentContents -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-Comment($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:try-Comment-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing Comment.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Comment" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="state" select="p:consumeT(17, $input, $state)"/>            <!-- ('(' ':') -->
    <xsl:variable name="state" select="p:try-Comment-1($input, $state)"/>
    <xsl:variable name="state" select="p:consumeT(28, $input, $state)"/>            <!-- (':' ')') -->
    <xsl:sequence select="$state"/>
  </xsl:function>

  <!--~
   ! Try parsing Whitespace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Whitespace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 8">                                         <!-- S^WS -->
          <xsl:variable name="state" select="p:consumeT(8, $input, $state)"/>       <!-- S^WS -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:try-Comment($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:sequence select="$state"/>
  </xsl:function>

  <!--~
   ! Parse NodeComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NodeComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 74">                                        <!-- 'is' -->
          <xsl:variable name="state" select="p:consume(74, $input, $state)"/>       <!-- 'is' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 32">                                        <!-- '<<' -->
          <xsl:variable name="state" select="p:consume(32, $input, $state)"/>       <!-- '<<' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(38, $input, $state)"/>       <!-- '>>' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NodeComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse GeneralComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-GeneralComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 34">                                        <!-- '=' -->
          <xsl:variable name="state" select="p:consume(34, $input, $state)"/>       <!-- '=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 13">                                        <!-- '!=' -->
          <xsl:variable name="state" select="p:consume(13, $input, $state)"/>       <!-- '!=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 31">                                        <!-- '<' -->
          <xsl:variable name="state" select="p:consume(31, $input, $state)"/>       <!-- '<' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 33">                                        <!-- '<=' -->
          <xsl:variable name="state" select="p:consume(33, $input, $state)"/>       <!-- '<=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 36">                                        <!-- '>' -->
          <xsl:variable name="state" select="p:consume(36, $input, $state)"/>       <!-- '>' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(37, $input, $state)"/>       <!-- '>=' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'GeneralComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ValueComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ValueComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 60">                                        <!-- 'eq' -->
          <xsl:variable name="state" select="p:consume(60, $input, $state)"/>       <!-- 'eq' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 83">                                        <!-- 'ne' -->
          <xsl:variable name="state" select="p:consume(83, $input, $state)"/>       <!-- 'ne' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 78">                                        <!-- 'lt' -->
          <xsl:variable name="state" select="p:consume(78, $input, $state)"/>       <!-- 'lt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 76">                                        <!-- 'le' -->
          <xsl:variable name="state" select="p:consume(76, $input, $state)"/>       <!-- 'le' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 68">                                        <!-- 'gt' -->
          <xsl:variable name="state" select="p:consume(68, $input, $state)"/>       <!-- 'gt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(67, $input, $state)"/>       <!-- 'ge' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ValueComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleTypeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleTypeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-TypeName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleTypeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SingleType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SingleType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleTypeName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(31, $input, $state)"/>         <!-- S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                                                         'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                                                         'return' | 'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' |
                                                                                         '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 39">                                        <!-- '?' -->
          <xsl:variable name="state" select="p:consume(39, $input, $state)"/>       <!-- '?' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SingleType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrowFunctionSpecifier.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowFunctionSpecifier" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 15">                                        <!-- '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-EQName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrowFunctionSpecifier', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PredicateList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PredicateList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(33, $input, $state)"/>     <!-- S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 41">                                     <!-- '[' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Predicate($input, $state)
            "/>
            <xsl:sequence select="p:parse-PredicateList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PredicateList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PredicateList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-PredicateList-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PredicateList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AbbrevForwardStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AbbrevForwardStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 40">                                        <!-- '@' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- '@' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-NodeTest($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AbbrevForwardStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForwardAxis.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForwardAxis" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 51">                                        <!-- 'child' -->
          <xsl:variable name="state" select="p:consume(51, $input, $state)"/>       <!-- 'child' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 53">                                        <!-- 'descendant' -->
          <xsl:variable name="state" select="p:consume(53, $input, $state)"/>       <!-- 'descendant' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'attribute' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 95">                                        <!-- 'self' -->
          <xsl:variable name="state" select="p:consume(95, $input, $state)"/>       <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 54">                                        <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:consume(54, $input, $state)"/>       <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 64">                                        <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:consume(64, $input, $state)"/>       <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 63">                                        <!-- 'following' -->
          <xsl:variable name="state" select="p:consume(63, $input, $state)"/>       <!-- 'following' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(81, $input, $state)"/>       <!-- 'namespace' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForwardAxis', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForwardStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForwardStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 48">                                       <!-- 'attribute' -->
          <xsl:variable name="state" select="p:lookahead2W(38, $input, $state)"/>   <!-- S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                                                         '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (51,                                          (: 'child' :)
                                         53,                                          (: 'descendant' :)
                                         54,                                          (: 'descendant-or-self' :)
                                         63,                                          (: 'following' :)
                                         64,                                          (: 'following-sibling' :)
                                         81,                                          (: 'namespace' :)
                                         95)">                                      <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead2W(35, $input, $state)"/>   <!-- S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 3760                                          (: 'attribute' '::' :)
                     or $state[$p:lk] = 3763                                          (: 'child' '::' :)
                     or $state[$p:lk] = 3765                                          (: 'descendant' '::' :)
                     or $state[$p:lk] = 3766                                          (: 'descendant-or-self' '::' :)
                     or $state[$p:lk] = 3775                                          (: 'following' '::' :)
                     or $state[$p:lk] = 3776                                          (: 'following-sibling' '::' :)
                     or $state[$p:lk] = 3793                                          (: 'namespace' '::' :)
                     or $state[$p:lk] = 3807">                                      <!-- 'self' '::' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForwardAxis($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AbbrevForwardStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForwardStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AbbrevReverseStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AbbrevReverseStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(24, $input, $state)"/>             <!-- '..' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AbbrevReverseStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NameTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NameTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 10">                                        <!-- Wildcard -->
          <xsl:variable name="state" select="p:consume(10, $input, $state)"/>       <!-- Wildcard -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-EQName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NameTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NodeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NodeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (48,                                          (: 'attribute' :)
                                         52,                                          (: 'comment' :)
                                         56,                                          (: 'document-node' :)
                                         57,                                          (: 'element' :)
                                         82,                                          (: 'namespace-node' :)
                                         84,                                          (: 'node' :)
                                         90,                                          (: 'processing-instruction' :)
                                         93,                                          (: 'schema-attribute' :)
                                         94,                                          (: 'schema-element' :)
                                         98)">                                      <!-- 'text' -->
          <xsl:variable name="state" select="p:lookahead2W(34, $input, $state)"/>   <!-- S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2096                                          (: 'attribute' '(' :)
                     or $state[$p:lk] = 2100                                          (: 'comment' '(' :)
                     or $state[$p:lk] = 2104                                          (: 'document-node' '(' :)
                     or $state[$p:lk] = 2105                                          (: 'element' '(' :)
                     or $state[$p:lk] = 2130                                          (: 'namespace-node' '(' :)
                     or $state[$p:lk] = 2132                                          (: 'node' '(' :)
                     or $state[$p:lk] = 2138                                          (: 'processing-instruction' '(' :)
                     or $state[$p:lk] = 2141                                          (: 'schema-attribute' '(' :)
                     or $state[$p:lk] = 2142                                          (: 'schema-element' '(' :)
                     or $state[$p:lk] = 2146">                                      <!-- 'text' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-KindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NameTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NodeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ReverseAxis.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ReverseAxis" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 87">                                        <!-- 'parent' -->
          <xsl:variable name="state" select="p:consume(87, $input, $state)"/>       <!-- 'parent' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 43">                                        <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:consume(43, $input, $state)"/>       <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 89">                                        <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:consume(89, $input, $state)"/>       <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 88">                                        <!-- 'preceding' -->
          <xsl:variable name="state" select="p:consume(88, $input, $state)"/>       <!-- 'preceding' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(44, $input, $state)"/>       <!-- 'ancestor-or-self' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(29, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ReverseAxis', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ReverseStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ReverseStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 24">                                        <!-- '..' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AbbrevReverseStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ReverseAxis($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ReverseStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AxisStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AxisStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (43,                                          (: 'ancestor' :)
                                         44,                                          (: 'ancestor-or-self' :)
                                         87,                                          (: 'parent' :)
                                         88,                                          (: 'preceding' :)
                                         89)">                                      <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:lookahead2W(35, $input, $state)"/>   <!-- S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 24                                            (: '..' :)
                     or $state[$p:lk] = 3755                                          (: 'ancestor' '::' :)
                     or $state[$p:lk] = 3756                                          (: 'ancestor-or-self' '::' :)
                     or $state[$p:lk] = 3799                                          (: 'parent' '::' :)
                     or $state[$p:lk] = 3800                                          (: 'preceding' '::' :)
                     or $state[$p:lk] = 3801">                                      <!-- 'preceding-sibling' '::' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ReverseStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForwardStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(33, $input, $state)"/>         <!-- S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PredicateList($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AxisStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Lookup.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Lookup" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(39, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="state" select="p:lookahead1W(23, $input, $state)"/>         <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-KeySpecifier($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Lookup', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Predicate.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Predicate" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(41, $input, $state)"/>             <!-- '[' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(42, $input, $state)"/>             <!-- ']' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Predicate', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse KeySpecifier.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-KeySpecifier" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 6">                                         <!-- NCName -->
          <xsl:variable name="state" select="p:consume(6, $input, $state)"/>        <!-- NCName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 1">                                         <!-- IntegerLiteral -->
          <xsl:variable name="state" select="p:consume(1, $input, $state)"/>        <!-- IntegerLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'KeySpecifier', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse UnaryLookup.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryLookup" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(39, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="state" select="p:lookahead1W(23, $input, $state)"/>         <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-KeySpecifier($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnaryLookup', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CurlyArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CurlyArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(46, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EnclosedExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CurlyArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SquareArrayConstructor (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SquareArrayConstructor-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(21, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-SquareArrayConstructor-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SquareArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SquareArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(41, $input, $state)"/>             <!-- '[' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         ']' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 42">                                       <!-- ']' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-SquareArrayConstructor-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(42, $input, $state)"/>             <!-- ']' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SquareArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 41">                                        <!-- '[' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SquareArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-CurlyArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapValueExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapValueExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapValueExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapKeyExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapKeyExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapKeyExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapConstructorEntry.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructorEntry" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MapKeyExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(27, $input, $state)"/>             <!-- ':' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MapValueExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapConstructorEntry', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production MapConstructor (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructor-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(21, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-MapConstructorEntry($input, $state)
            "/>
            <xsl:sequence select="p:parse-MapConstructor-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse MapConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(79, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:consume(104, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(56, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 107">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapConstructorEntry($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-MapConstructor-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(107, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse EnclosedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-EnclosedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(104, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(56, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 107">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(107, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'EnclosedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionBody.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionBody" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EnclosedExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionBody', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse OccurrenceIndicator.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OccurrenceIndicator" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 39">                                        <!-- '?' -->
          <xsl:variable name="state" select="p:consume(39, $input, $state)"/>       <!-- '?' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 19">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '+' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'OccurrenceIndicator', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ParenthesizedItemType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParenthesizedItemType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ItemType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParenthesizedItemType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypedArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(46, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(46, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 46">                                       <!-- 'array' -->
          <xsl:variable name="state" select="p:lookahead2W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2094">                               <!-- 'array' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(48, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | '*' |
                                                                                             'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                             'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 313390">                                    <!-- 'array' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AtomicOrUnionType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AtomicOrUnionType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AtomicOrUnionType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypedMapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedMapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(79, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AtomicOrUnionType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ',' -->
    <xsl:variable name="state" select="p:consume(21, $input, $state)"/>             <!-- ',' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedMapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyMapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyMapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(79, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyMapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 79">                                       <!-- 'map' -->
          <xsl:variable name="state" select="p:lookahead2W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2127">                               <!-- 'map' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(45, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | '*' |
                                                                                             'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                             'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 313423">                                    <!-- 'map' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyMapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedMapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production TypedFunctionTest (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedFunctionTest-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(21, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SequenceType($input, $state)
            "/>
            <xsl:sequence select="p:parse-TypedFunctionTest-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse TypedFunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedFunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(66, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(47, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | ')' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 18">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-TypedFunctionTest-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>          <!-- S^WS | ('(' ':') | 'as' -->
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'as' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedFunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyFunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyFunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(66, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyFunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 66">                                       <!-- 'function' -->
          <xsl:variable name="state" select="p:lookahead2W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2114">                               <!-- 'function' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(50, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | ')' |
                                                                                             '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                                                             'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                             'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                             'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 313410">                                    <!-- 'function' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyFunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedFunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyKindTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyKindTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(84, $input, $state)"/>             <!-- 'node' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyKindTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NamespaceNodeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NamespaceNodeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(82, $input, $state)"/>             <!-- 'namespace-node' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NamespaceNodeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TextTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TextTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(98, $input, $state)"/>             <!-- 'text' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TextTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CommentTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CommentTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(52, $input, $state)"/>             <!-- 'comment' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CommentTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PITest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PITest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(90, $input, $state)"/>             <!-- 'processing-instruction' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/>         <!-- StringLiteral | NCName | S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 18">                                       <!-- ')' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 6">                                   <!-- NCName -->
                <xsl:variable name="state" select="p:consume(6, $input, $state)"/>  <!-- NCName -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:consume(4, $input, $state)"/>  <!-- StringLiteral -->
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PITest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AttributeName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SchemaAttributeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SchemaAttributeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(93, $input, $state)"/>             <!-- 'schema-attribute' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AttributeDeclaration($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SchemaAttributeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttribNameOrWildcard.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttribNameOrWildcard" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 19">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttributeName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttribNameOrWildcard', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(48, $input, $state)"/>             <!-- 'attribute' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(49, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' | '*' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 18">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttribNameOrWildcard($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>   <!-- S^WS | ('(' ':') | ')' | ',' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 21">                                  <!-- ',' -->
                <xsl:variable name="state" select="p:consume(21, $input, $state)"/> <!-- ',' -->
                <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                             'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                             'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-TypeName($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ElementName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SchemaElementTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SchemaElementTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(94, $input, $state)"/>             <!-- 'schema-element' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ElementDeclaration($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SchemaElementTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementNameOrWildcard.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementNameOrWildcard" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 19">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementNameOrWildcard', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(57, $input, $state)"/>             <!-- 'element' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(49, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' | '*' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 18">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementNameOrWildcard($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>   <!-- S^WS | ('(' ':') | ')' | ',' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 21">                                  <!-- ',' -->
                <xsl:variable name="state" select="p:consume(21, $input, $state)"/> <!-- ',' -->
                <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                             'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                             'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-TypeName($input, $state)
                "/>
                <xsl:variable name="state" select="p:lookahead1W(18, $input, $state)"/> <!-- S^WS | ('(' ':') | ')' | '?' -->
                <xsl:variable name="state" as="item()+">
                  <xsl:choose>
                    <xsl:when test="$state[$p:error]">
                      <xsl:sequence select="$state"/>
                    </xsl:when>
                    <xsl:when test="$state[$p:l1] = 39">                            <!-- '?' -->
                      <xsl:variable name="state" select="p:consume(39, $input, $state)"/> <!-- '?' -->
                      <xsl:sequence select="$state"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:sequence select="$state"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:variable>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse DocumentTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DocumentTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(56, $input, $state)"/>             <!-- 'document-node' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(22, $input, $state)"/>         <!-- S^WS | ('(' ':') | ')' | 'element' | 'schema-element' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 18">                                       <!-- ')' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 57">                                  <!-- 'element' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-ElementTest($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-SchemaElementTest($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'DocumentTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse KindTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-KindTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 56">                                        <!-- 'document-node' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-DocumentTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 57">                                        <!-- 'element' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttributeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 94">                                        <!-- 'schema-element' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 93">                                        <!-- 'schema-attribute' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaAttributeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 90">                                        <!-- 'processing-instruction' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PITest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 52">                                        <!-- 'comment' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-CommentTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 98">                                        <!-- 'text' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TextTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 82">                                        <!-- 'namespace-node' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NamespaceNodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyKindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'KindTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ItemType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ItemType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (46,                                          (: 'array' :)
                                         48,                                          (: 'attribute' :)
                                         52,                                          (: 'comment' :)
                                         56,                                          (: 'document-node' :)
                                         57,                                          (: 'element' :)
                                         66,                                          (: 'function' :)
                                         75,                                          (: 'item' :)
                                         79,                                          (: 'map' :)
                                         82,                                          (: 'namespace-node' :)
                                         84,                                          (: 'node' :)
                                         90,                                          (: 'processing-instruction' :)
                                         93,                                          (: 'schema-attribute' :)
                                         94,                                          (: 'schema-element' :)
                                         98)">                                      <!-- 'text' -->
          <xsl:variable name="state" select="p:lookahead2W(30, $input, $state)"/>   <!-- S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         ':' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2096                                          (: 'attribute' '(' :)
                     or $state[$p:lk] = 2100                                          (: 'comment' '(' :)
                     or $state[$p:lk] = 2104                                          (: 'document-node' '(' :)
                     or $state[$p:lk] = 2105                                          (: 'element' '(' :)
                     or $state[$p:lk] = 2130                                          (: 'namespace-node' '(' :)
                     or $state[$p:lk] = 2132                                          (: 'node' '(' :)
                     or $state[$p:lk] = 2138                                          (: 'processing-instruction' '(' :)
                     or $state[$p:lk] = 2141                                          (: 'schema-attribute' '(' :)
                     or $state[$p:lk] = 2142                                          (: 'schema-element' '(' :)
                     or $state[$p:lk] = 2146">                                      <!-- 'text' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-KindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2123">                                      <!-- 'item' '(' -->
          <xsl:variable name="state" select="p:consume(75, $input, $state)"/>       <!-- 'item' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" select="p:consume(16, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>    <!-- S^WS | ('(' ':') | ')' -->
          <xsl:variable name="state" select="p:consume(18, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2114">                                      <!-- 'function' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2127">                                      <!-- 'map' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2094">                                      <!-- 'array' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 16">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedItemType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AtomicOrUnionType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ItemType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SequenceType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SequenceType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 59">                                       <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:lookahead2W(30, $input, $state)"/>   <!-- S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         ':' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2107">                                      <!-- 'empty-sequence' '(' -->
          <xsl:variable name="state" select="p:consume(59, $input, $state)"/>       <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" select="p:consume(16, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>    <!-- S^WS | ('(' ':') | ')' -->
          <xsl:variable name="state" select="p:consume(18, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ItemType($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(28, $input, $state)"/>   <!-- S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 19                                      (: '*' :)
                           or $state[$p:l1] = 20                                      (: '+' :)
                           or $state[$p:l1] = 39">                                  <!-- '?' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-OccurrenceIndicator($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SequenceType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypeDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypeDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'as' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypeDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Param.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Param" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(21, $input, $state)"/>         <!-- S^WS | ('(' ':') | ')' | ',' | 'as' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 47">                                        <!-- 'as' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Param', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ParamList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParamList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(21, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Param($input, $state)
            "/>
            <xsl:sequence select="p:parse-ParamList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ParamList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParamList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Param($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-ParamList-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParamList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse InlineFunctionExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-InlineFunctionExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(66, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(16, $input, $state)"/>         <!-- S^WS | '$' | ('(' ':') | ')' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 15">                                        <!-- '$' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParamList($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'as' | '{' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 47">                                        <!-- 'as' -->
          <xsl:variable name="state" select="p:consume(47, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionBody($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'InlineFunctionExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NamedFunctionRef.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NamedFunctionRef" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionEQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WS | '#' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(14, $input, $state)"/>             <!-- '#' -->
    <xsl:variable name="state" select="p:lookahead1W(0, $input, $state)"/>          <!-- IntegerLiteral | S^WS | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(1, $input, $state)"/>              <!-- IntegerLiteral -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NamedFunctionRef', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionItemExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionItemExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 66">                                        <!-- 'function' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-InlineFunctionExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NamedFunctionRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionItemExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArgumentPlaceholder.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentPlaceholder" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(39, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArgumentPlaceholder', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Argument.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Argument" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 39">                                       <!-- '?' -->
          <xsl:variable name="state" select="p:lookahead2W(24, $input, $state)"/>   <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | ')' | '*' | ',' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2343                                          (: '?' ')' :)
                     or $state[$p:lk] = 2727">                                      <!-- '?' ',' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArgumentPlaceholder($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Argument', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ArgumentList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(21, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Argument($input, $state)
            "/>
            <xsl:sequence select="p:parse-ArgumentList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ArgumentList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | ')' | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' |
                                                                                         '[' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 18">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Argument($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-ArgumentList-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArgumentList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionEQName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionEQName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 5">                                         <!-- URIQualifiedName -->
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- URIQualifiedName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionEQName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionCall.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionCall" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionEQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ArgumentList($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionCall', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ContextItemExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ContextItemExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(23, $input, $state)"/>             <!-- '.' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ContextItemExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ParenthesizedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParenthesizedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | ')' | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' |
                                                                                         '[' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 18">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParenthesizedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse VarRef.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-VarRef" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'VarRef', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NumericLiteral.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NumericLiteral" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 1">                                         <!-- IntegerLiteral -->
          <xsl:variable name="state" select="p:consume(1, $input, $state)"/>        <!-- IntegerLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 2">                                         <!-- DecimalLiteral -->
          <xsl:variable name="state" select="p:consume(2, $input, $state)"/>        <!-- DecimalLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(3, $input, $state)"/>        <!-- DoubleLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NumericLiteral', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Literal.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Literal" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 4">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="p:consume(4, $input, $state)"/>        <!-- StringLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NumericLiteral($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Literal', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PrimaryExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PrimaryExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (5,                                           (: URIQualifiedName :)
                                         7,                                           (: QName^Token :)
                                         43,                                          (: 'ancestor' :)
                                         44,                                          (: 'ancestor-or-self' :)
                                         45,                                          (: 'and' :)
                                         49,                                          (: 'cast' :)
                                         50,                                          (: 'castable' :)
                                         51,                                          (: 'child' :)
                                         53,                                          (: 'descendant' :)
                                         54,                                          (: 'descendant-or-self' :)
                                         55,                                          (: 'div' :)
                                         58,                                          (: 'else' :)
                                         60,                                          (: 'eq' :)
                                         61,                                          (: 'every' :)
                                         62,                                          (: 'except' :)
                                         63,                                          (: 'following' :)
                                         64,                                          (: 'following-sibling' :)
                                         65,                                          (: 'for' :)
                                         67,                                          (: 'ge' :)
                                         68,                                          (: 'gt' :)
                                         69,                                          (: 'idiv' :)
                                         72,                                          (: 'instance' :)
                                         73,                                          (: 'intersect' :)
                                         74,                                          (: 'is' :)
                                         76,                                          (: 'le' :)
                                         77,                                          (: 'let' :)
                                         78,                                          (: 'lt' :)
                                         80,                                          (: 'mod' :)
                                         81,                                          (: 'namespace' :)
                                         83,                                          (: 'ne' :)
                                         86,                                          (: 'or' :)
                                         87,                                          (: 'parent' :)
                                         88,                                          (: 'preceding' :)
                                         89,                                          (: 'preceding-sibling' :)
                                         91,                                          (: 'return' :)
                                         92,                                          (: 'satisfies' :)
                                         95,                                          (: 'self' :)
                                         96,                                          (: 'some' :)
                                         100,                                         (: 'to' :)
                                         101,                                         (: 'treat' :)
                                         103)">                                     <!-- 'union' -->
          <xsl:variable name="state" select="p:lookahead2W(15, $input, $state)"/>   <!-- S^WS | '#' | '(' | ('(' ':') -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 1                                             (: IntegerLiteral :)
                     or $state[$p:lk] = 2                                             (: DecimalLiteral :)
                     or $state[$p:lk] = 3                                             (: DoubleLiteral :)
                     or $state[$p:lk] = 4">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Literal($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 15">                                        <!-- '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 16">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 23">                                        <!-- '.' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ContextItemExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2053                                          (: URIQualifiedName '(' :)
                     or $state[$p:lk] = 2055                                          (: QName^Token '(' :)
                     or $state[$p:lk] = 2091                                          (: 'ancestor' '(' :)
                     or $state[$p:lk] = 2092                                          (: 'ancestor-or-self' '(' :)
                     or $state[$p:lk] = 2093                                          (: 'and' '(' :)
                     or $state[$p:lk] = 2097                                          (: 'cast' '(' :)
                     or $state[$p:lk] = 2098                                          (: 'castable' '(' :)
                     or $state[$p:lk] = 2099                                          (: 'child' '(' :)
                     or $state[$p:lk] = 2101                                          (: 'descendant' '(' :)
                     or $state[$p:lk] = 2102                                          (: 'descendant-or-self' '(' :)
                     or $state[$p:lk] = 2103                                          (: 'div' '(' :)
                     or $state[$p:lk] = 2106                                          (: 'else' '(' :)
                     or $state[$p:lk] = 2108                                          (: 'eq' '(' :)
                     or $state[$p:lk] = 2109                                          (: 'every' '(' :)
                     or $state[$p:lk] = 2110                                          (: 'except' '(' :)
                     or $state[$p:lk] = 2111                                          (: 'following' '(' :)
                     or $state[$p:lk] = 2112                                          (: 'following-sibling' '(' :)
                     or $state[$p:lk] = 2113                                          (: 'for' '(' :)
                     or $state[$p:lk] = 2115                                          (: 'ge' '(' :)
                     or $state[$p:lk] = 2116                                          (: 'gt' '(' :)
                     or $state[$p:lk] = 2117                                          (: 'idiv' '(' :)
                     or $state[$p:lk] = 2120                                          (: 'instance' '(' :)
                     or $state[$p:lk] = 2121                                          (: 'intersect' '(' :)
                     or $state[$p:lk] = 2122                                          (: 'is' '(' :)
                     or $state[$p:lk] = 2124                                          (: 'le' '(' :)
                     or $state[$p:lk] = 2125                                          (: 'let' '(' :)
                     or $state[$p:lk] = 2126                                          (: 'lt' '(' :)
                     or $state[$p:lk] = 2128                                          (: 'mod' '(' :)
                     or $state[$p:lk] = 2129                                          (: 'namespace' '(' :)
                     or $state[$p:lk] = 2131                                          (: 'ne' '(' :)
                     or $state[$p:lk] = 2134                                          (: 'or' '(' :)
                     or $state[$p:lk] = 2135                                          (: 'parent' '(' :)
                     or $state[$p:lk] = 2136                                          (: 'preceding' '(' :)
                     or $state[$p:lk] = 2137                                          (: 'preceding-sibling' '(' :)
                     or $state[$p:lk] = 2139                                          (: 'return' '(' :)
                     or $state[$p:lk] = 2140                                          (: 'satisfies' '(' :)
                     or $state[$p:lk] = 2143                                          (: 'self' '(' :)
                     or $state[$p:lk] = 2144                                          (: 'some' '(' :)
                     or $state[$p:lk] = 2148                                          (: 'to' '(' :)
                     or $state[$p:lk] = 2149                                          (: 'treat' '(' :)
                     or $state[$p:lk] = 2151">                                      <!-- 'union' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionCall($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 79">                                        <!-- 'map' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 41                                            (: '[' :)
                     or $state[$p:lk] = 46">                                        <!-- 'array' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 39">                                        <!-- '?' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-UnaryLookup($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionItemExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PrimaryExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PostfixExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PostfixExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(39, $input, $state)"/>     <!-- S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '?' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 16                                         (: '(' :)
                      and $state[$p:l1] != 39                                         (: '?' :)
                      and $state[$p:l1] != 41">                                     <!-- '[' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 41">                                <!-- '[' -->
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-Predicate($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 16">                                <!-- '(' -->
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-ArgumentList($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-Lookup($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-PostfixExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PostfixExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PostfixExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PrimaryExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-PostfixExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PostfixExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse StepExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StepExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 66">                                       <!-- 'function' -->
          <xsl:variable name="state" select="p:lookahead2W(34, $input, $state)"/>   <!-- S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (46,                                          (: 'array' :)
                                         79)">                                      <!-- 'map' -->
          <xsl:variable name="state" select="p:lookahead2W(36, $input, $state)"/>   <!-- S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (43,                                          (: 'ancestor' :)
                                         44,                                          (: 'ancestor-or-self' :)
                                         51,                                          (: 'child' :)
                                         53,                                          (: 'descendant' :)
                                         54,                                          (: 'descendant-or-self' :)
                                         63,                                          (: 'following' :)
                                         64,                                          (: 'following-sibling' :)
                                         81,                                          (: 'namespace' :)
                                         87,                                          (: 'parent' :)
                                         88,                                          (: 'preceding' :)
                                         89,                                          (: 'preceding-sibling' :)
                                         95)">                                      <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead2W(41, $input, $state)"/>   <!-- S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                                         ',' | '-' | '/' | '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' |
                                                                                         '>' | '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (5,                                           (: URIQualifiedName :)
                                         7,                                           (: QName^Token :)
                                         45,                                          (: 'and' :)
                                         49,                                          (: 'cast' :)
                                         50,                                          (: 'castable' :)
                                         55,                                          (: 'div' :)
                                         58,                                          (: 'else' :)
                                         60,                                          (: 'eq' :)
                                         61,                                          (: 'every' :)
                                         62,                                          (: 'except' :)
                                         65,                                          (: 'for' :)
                                         67,                                          (: 'ge' :)
                                         68,                                          (: 'gt' :)
                                         69,                                          (: 'idiv' :)
                                         72,                                          (: 'instance' :)
                                         73,                                          (: 'intersect' :)
                                         74,                                          (: 'is' :)
                                         76,                                          (: 'le' :)
                                         77,                                          (: 'let' :)
                                         78,                                          (: 'lt' :)
                                         80,                                          (: 'mod' :)
                                         83,                                          (: 'ne' :)
                                         86,                                          (: 'or' :)
                                         91,                                          (: 'return' :)
                                         92,                                          (: 'satisfies' :)
                                         96,                                          (: 'some' :)
                                         100,                                         (: 'to' :)
                                         101,                                         (: 'treat' :)
                                         103)">                                     <!-- 'union' -->
          <xsl:variable name="state" select="p:lookahead2W(37, $input, $state)"/>   <!-- S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                                         ',' | '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                                                         '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 1                                             (: IntegerLiteral :)
                     or $state[$p:lk] = 2                                             (: DecimalLiteral :)
                     or $state[$p:lk] = 3                                             (: DoubleLiteral :)
                     or $state[$p:lk] = 4                                             (: StringLiteral :)
                     or $state[$p:lk] = 15                                            (: '$' :)
                     or $state[$p:lk] = 16                                            (: '(' :)
                     or $state[$p:lk] = 23                                            (: '.' :)
                     or $state[$p:lk] = 39                                            (: '?' :)
                     or $state[$p:lk] = 41                                            (: '[' :)
                     or $state[$p:lk] = 1797                                          (: URIQualifiedName '#' :)
                     or $state[$p:lk] = 1799                                          (: QName^Token '#' :)
                     or $state[$p:lk] = 1835                                          (: 'ancestor' '#' :)
                     or $state[$p:lk] = 1836                                          (: 'ancestor-or-self' '#' :)
                     or $state[$p:lk] = 1837                                          (: 'and' '#' :)
                     or $state[$p:lk] = 1841                                          (: 'cast' '#' :)
                     or $state[$p:lk] = 1842                                          (: 'castable' '#' :)
                     or $state[$p:lk] = 1843                                          (: 'child' '#' :)
                     or $state[$p:lk] = 1845                                          (: 'descendant' '#' :)
                     or $state[$p:lk] = 1846                                          (: 'descendant-or-self' '#' :)
                     or $state[$p:lk] = 1847                                          (: 'div' '#' :)
                     or $state[$p:lk] = 1850                                          (: 'else' '#' :)
                     or $state[$p:lk] = 1852                                          (: 'eq' '#' :)
                     or $state[$p:lk] = 1853                                          (: 'every' '#' :)
                     or $state[$p:lk] = 1854                                          (: 'except' '#' :)
                     or $state[$p:lk] = 1855                                          (: 'following' '#' :)
                     or $state[$p:lk] = 1856                                          (: 'following-sibling' '#' :)
                     or $state[$p:lk] = 1857                                          (: 'for' '#' :)
                     or $state[$p:lk] = 1859                                          (: 'ge' '#' :)
                     or $state[$p:lk] = 1860                                          (: 'gt' '#' :)
                     or $state[$p:lk] = 1861                                          (: 'idiv' '#' :)
                     or $state[$p:lk] = 1864                                          (: 'instance' '#' :)
                     or $state[$p:lk] = 1865                                          (: 'intersect' '#' :)
                     or $state[$p:lk] = 1866                                          (: 'is' '#' :)
                     or $state[$p:lk] = 1868                                          (: 'le' '#' :)
                     or $state[$p:lk] = 1869                                          (: 'let' '#' :)
                     or $state[$p:lk] = 1870                                          (: 'lt' '#' :)
                     or $state[$p:lk] = 1872                                          (: 'mod' '#' :)
                     or $state[$p:lk] = 1873                                          (: 'namespace' '#' :)
                     or $state[$p:lk] = 1875                                          (: 'ne' '#' :)
                     or $state[$p:lk] = 1878                                          (: 'or' '#' :)
                     or $state[$p:lk] = 1879                                          (: 'parent' '#' :)
                     or $state[$p:lk] = 1880                                          (: 'preceding' '#' :)
                     or $state[$p:lk] = 1881                                          (: 'preceding-sibling' '#' :)
                     or $state[$p:lk] = 1883                                          (: 'return' '#' :)
                     or $state[$p:lk] = 1884                                          (: 'satisfies' '#' :)
                     or $state[$p:lk] = 1887                                          (: 'self' '#' :)
                     or $state[$p:lk] = 1888                                          (: 'some' '#' :)
                     or $state[$p:lk] = 1892                                          (: 'to' '#' :)
                     or $state[$p:lk] = 1893                                          (: 'treat' '#' :)
                     or $state[$p:lk] = 1895                                          (: 'union' '#' :)
                     or $state[$p:lk] = 2053                                          (: URIQualifiedName '(' :)
                     or $state[$p:lk] = 2055                                          (: QName^Token '(' :)
                     or $state[$p:lk] = 2091                                          (: 'ancestor' '(' :)
                     or $state[$p:lk] = 2092                                          (: 'ancestor-or-self' '(' :)
                     or $state[$p:lk] = 2093                                          (: 'and' '(' :)
                     or $state[$p:lk] = 2097                                          (: 'cast' '(' :)
                     or $state[$p:lk] = 2098                                          (: 'castable' '(' :)
                     or $state[$p:lk] = 2099                                          (: 'child' '(' :)
                     or $state[$p:lk] = 2101                                          (: 'descendant' '(' :)
                     or $state[$p:lk] = 2102                                          (: 'descendant-or-self' '(' :)
                     or $state[$p:lk] = 2103                                          (: 'div' '(' :)
                     or $state[$p:lk] = 2106                                          (: 'else' '(' :)
                     or $state[$p:lk] = 2108                                          (: 'eq' '(' :)
                     or $state[$p:lk] = 2109                                          (: 'every' '(' :)
                     or $state[$p:lk] = 2110                                          (: 'except' '(' :)
                     or $state[$p:lk] = 2111                                          (: 'following' '(' :)
                     or $state[$p:lk] = 2112                                          (: 'following-sibling' '(' :)
                     or $state[$p:lk] = 2113                                          (: 'for' '(' :)
                     or $state[$p:lk] = 2114                                          (: 'function' '(' :)
                     or $state[$p:lk] = 2115                                          (: 'ge' '(' :)
                     or $state[$p:lk] = 2116                                          (: 'gt' '(' :)
                     or $state[$p:lk] = 2117                                          (: 'idiv' '(' :)
                     or $state[$p:lk] = 2120                                          (: 'instance' '(' :)
                     or $state[$p:lk] = 2121                                          (: 'intersect' '(' :)
                     or $state[$p:lk] = 2122                                          (: 'is' '(' :)
                     or $state[$p:lk] = 2124                                          (: 'le' '(' :)
                     or $state[$p:lk] = 2125                                          (: 'let' '(' :)
                     or $state[$p:lk] = 2126                                          (: 'lt' '(' :)
                     or $state[$p:lk] = 2128                                          (: 'mod' '(' :)
                     or $state[$p:lk] = 2129                                          (: 'namespace' '(' :)
                     or $state[$p:lk] = 2131                                          (: 'ne' '(' :)
                     or $state[$p:lk] = 2134                                          (: 'or' '(' :)
                     or $state[$p:lk] = 2135                                          (: 'parent' '(' :)
                     or $state[$p:lk] = 2136                                          (: 'preceding' '(' :)
                     or $state[$p:lk] = 2137                                          (: 'preceding-sibling' '(' :)
                     or $state[$p:lk] = 2139                                          (: 'return' '(' :)
                     or $state[$p:lk] = 2140                                          (: 'satisfies' '(' :)
                     or $state[$p:lk] = 2143                                          (: 'self' '(' :)
                     or $state[$p:lk] = 2144                                          (: 'some' '(' :)
                     or $state[$p:lk] = 2148                                          (: 'to' '(' :)
                     or $state[$p:lk] = 2149                                          (: 'treat' '(' :)
                     or $state[$p:lk] = 2151                                          (: 'union' '(' :)
                     or $state[$p:lk] = 13358                                         (: 'array' '{' :)
                     or $state[$p:lk] = 13391">                                     <!-- 'map' '{' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PostfixExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AxisStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'StepExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production RelativePathExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RelativePathExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 25                                         (: '/' :)
                      and $state[$p:l1] != 26">                                     <!-- '//' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 25">                                <!-- '/' -->
                  <xsl:variable name="state" select="p:consume(25, $input, $state)"/> <!-- '/' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(26, $input, $state)"/> <!-- '//' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(51, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-StepExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-RelativePathExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse RelativePathExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RelativePathExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-StepExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-RelativePathExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'RelativePathExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PathExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PathExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 25">                                        <!-- '/' -->
          <xsl:variable name="state" select="p:consume(25, $input, $state)"/>       <!-- '/' -->
          <xsl:variable name="state" select="p:lookahead1W(57, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | EOF | '!' | '!=' |
                                                                                         '$' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' |
                                                                                         ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '?' | '@' |
                                                                                         '[' | ']' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                                                         'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                         'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                         'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                         'following' | 'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                                                         'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' |
                                                                                         'let' | 'lt' | 'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' |
                                                                                         'node' | 'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '|' | '||' | '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 11                                      (: EOF :)
                           or $state[$p:l1] = 12                                      (: '!' :)
                           or $state[$p:l1] = 13                                      (: '!=' :)
                           or $state[$p:l1] = 18                                      (: ')' :)
                           or $state[$p:l1] = 19                                      (: '*' :)
                           or $state[$p:l1] = 20                                      (: '+' :)
                           or $state[$p:l1] = 21                                      (: ',' :)
                           or $state[$p:l1] = 22                                      (: '-' :)
                           or $state[$p:l1] = 27                                      (: ':' :)
                           or $state[$p:l1] = 31                                      (: '&lt;' :)
                           or $state[$p:l1] = 32                                      (: '&lt;&lt;' :)
                           or $state[$p:l1] = 33                                      (: '&lt;=' :)
                           or $state[$p:l1] = 34                                      (: '=' :)
                           or $state[$p:l1] = 35                                      (: '=>' :)
                           or $state[$p:l1] = 36                                      (: '>' :)
                           or $state[$p:l1] = 37                                      (: '>=' :)
                           or $state[$p:l1] = 38                                      (: '>>' :)
                           or $state[$p:l1] = 42                                      (: ']' :)
                           or $state[$p:l1] = 105                                     (: '|' :)
                           or $state[$p:l1] = 106                                     (: '||' :)
                           or $state[$p:l1] = 107">                                 <!-- '}' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-RelativePathExpr($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 26">                                        <!-- '//' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '//' -->
          <xsl:variable name="state" select="p:lookahead1W(51, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PathExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleMapExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleMapExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 12">                                     <!-- '!' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(12, $input, $state)"/>     <!-- '!' -->
            <xsl:variable name="state" select="p:lookahead1W(52, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '/' | '//' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-PathExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleMapExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleMapExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleMapExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PathExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleMapExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleMapExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ValueExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ValueExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleMapExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ValueExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production UnaryExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>     <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 20                                         (: '+' :)
                      and $state[$p:l1] != 22">                                     <!-- '-' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 22">                                <!-- '-' -->
                  <xsl:variable name="state" select="p:consume(22, $input, $state)"/> <!-- '-' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(20, $input, $state)"/> <!-- '+' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-UnaryExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse UnaryExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-UnaryExpr-1($input, $state)"/>
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ValueExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnaryExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ArrowExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(32, $input, $state)"/>     <!-- S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | ']' | 'and' |
                                                                                         'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' |
                                                                                         'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' |
                                                                                         'or' | 'return' | 'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' |
                                                                                         '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 35">                                     <!-- '=>' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(35, $input, $state)"/>     <!-- '=>' -->
            <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '$' | '(' | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArrowFunctionSpecifier($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>  <!-- S^WS | '(' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArgumentList($input, $state)
            "/>
            <xsl:sequence select="p:parse-ArrowExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ArrowExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnaryExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-ArrowExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrowExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CastExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CastExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ArrowExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'cast' -->
          <xsl:variable name="state" select="p:consume(49, $input, $state)"/>       <!-- 'cast' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(47, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SingleType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CastExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CastableExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CastableExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-CastExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(29, $input, $state)"/>         <!-- S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                                                         'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                                                         'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                                                         'return' | 'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' |
                                                                                         '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 50">                                        <!-- 'castable' -->
          <xsl:variable name="state" select="p:consume(50, $input, $state)"/>       <!-- 'castable' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(47, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SingleType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CastableExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TreatExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TreatExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-CastableExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(27, $input, $state)"/>         <!-- S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 101">                                       <!-- 'treat' -->
          <xsl:variable name="state" select="p:consume(101, $input, $state)"/>      <!-- 'treat' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(47, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TreatExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse InstanceofExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-InstanceofExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-TreatExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(26, $input, $state)"/>         <!-- S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 72">                                        <!-- 'instance' -->
          <xsl:variable name="state" select="p:consume(72, $input, $state)"/>       <!-- 'instance' -->
          <xsl:variable name="state" select="p:lookahead1W(11, $input, $state)"/>   <!-- S^WS | ('(' ':') | 'of' -->
          <xsl:variable name="state" select="p:consume(85, $input, $state)"/>       <!-- 'of' -->
          <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'InstanceofExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IntersectExceptExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(25, $input, $state)"/>     <!-- S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'union' | '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 62                                         (: 'except' :)
                      and $state[$p:l1] != 73">                                     <!-- 'intersect' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 73">                                <!-- 'intersect' -->
                  <xsl:variable name="state" select="p:consume(73, $input, $state)"/> <!-- 'intersect' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(62, $input, $state)"/> <!-- 'except' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-InstanceofExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-IntersectExceptExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse IntersectExceptExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IntersectExceptExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-InstanceofExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-IntersectExceptExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'IntersectExceptExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production UnionExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnionExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 103                                        (: 'union' :)
                      and $state[$p:l1] != 105">                                    <!-- '|' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 103">                               <!-- 'union' -->
                  <xsl:variable name="state" select="p:consume(103, $input, $state)"/> <!-- 'union' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(105, $input, $state)"/> <!-- '|' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-IntersectExceptExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-UnionExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse UnionExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnionExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-IntersectExceptExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-UnionExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnionExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MultiplicativeExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 19                                         (: '*' :)
                      and $state[$p:l1] != 55                                         (: 'div' :)
                      and $state[$p:l1] != 69                                         (: 'idiv' :)
                      and $state[$p:l1] != 80">                                     <!-- 'mod' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 19">                                <!-- '*' -->
                  <xsl:variable name="state" select="p:consume(19, $input, $state)"/> <!-- '*' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 55">                                <!-- 'div' -->
                  <xsl:variable name="state" select="p:consume(55, $input, $state)"/> <!-- 'div' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 69">                                <!-- 'idiv' -->
                  <xsl:variable name="state" select="p:consume(69, $input, $state)"/> <!-- 'idiv' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(80, $input, $state)"/> <!-- 'mod' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-UnionExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-MultiplicativeExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse MultiplicativeExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MultiplicativeExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnionExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-MultiplicativeExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MultiplicativeExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AdditiveExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AdditiveExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 20                                         (: '+' :)
                      and $state[$p:l1] != 22">                                     <!-- '-' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 20">                                <!-- '+' -->
                  <xsl:variable name="state" select="p:consume(20, $input, $state)"/> <!-- '+' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(22, $input, $state)"/> <!-- '-' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-MultiplicativeExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-AdditiveExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AdditiveExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AdditiveExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MultiplicativeExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AdditiveExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AdditiveExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse RangeExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RangeExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AdditiveExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 100">                                       <!-- 'to' -->
          <xsl:variable name="state" select="p:consume(100, $input, $state)"/>      <!-- 'to' -->
          <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AdditiveExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'RangeExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production StringConcatExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StringConcatExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 106">                                    <!-- '||' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(106, $input, $state)"/>    <!-- '||' -->
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-RangeExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-StringConcatExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse StringConcatExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StringConcatExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-RangeExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-StringConcatExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'StringConcatExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ComparisonExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ComparisonExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-StringConcatExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 11                                           (: EOF :)
                    and $state[$p:l1] != 18                                           (: ')' :)
                    and $state[$p:l1] != 21                                           (: ',' :)
                    and $state[$p:l1] != 27                                           (: ':' :)
                    and $state[$p:l1] != 42                                           (: ']' :)
                    and $state[$p:l1] != 45                                           (: 'and' :)
                    and $state[$p:l1] != 58                                           (: 'else' :)
                    and $state[$p:l1] != 86                                           (: 'or' :)
                    and $state[$p:l1] != 91                                           (: 'return' :)
                    and $state[$p:l1] != 92                                           (: 'satisfies' :)
                    and $state[$p:l1] != 107">                                      <!-- '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 60                                      (: 'eq' :)
                           or $state[$p:l1] = 67                                      (: 'ge' :)
                           or $state[$p:l1] = 68                                      (: 'gt' :)
                           or $state[$p:l1] = 76                                      (: 'le' :)
                           or $state[$p:l1] = 78                                      (: 'lt' :)
                           or $state[$p:l1] = 83">                                  <!-- 'ne' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-ValueComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 32                                      (: '&lt;&lt;' :)
                           or $state[$p:l1] = 38                                      (: '>>' :)
                           or $state[$p:l1] = 74">                                  <!-- 'is' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-NodeComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-GeneralComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-StringConcatExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ComparisonExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AndExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AndExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 45">                                     <!-- 'and' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(45, $input, $state)"/>     <!-- 'and' -->
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ComparisonExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-AndExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AndExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AndExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ComparisonExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AndExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AndExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production OrExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OrExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 86">                                     <!-- 'or' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(86, $input, $state)"/>     <!-- 'or' -->
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-AndExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-OrExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse OrExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OrExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AndExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-OrExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'OrExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse IfExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IfExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(70, $input, $state)"/>             <!-- 'if' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(18, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(12, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'then' -->
    <xsl:variable name="state" select="p:consume(99, $input, $state)"/>             <!-- 'then' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(58, $input, $state)"/>             <!-- 'else' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'IfExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production QuantifiedExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QuantifiedExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(21, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:consume(15, $input, $state)"/>     <!-- '$' -->
            <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-VarName($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/> <!-- S^WS | ('(' ':') | 'in' -->
            <xsl:variable name="state" select="p:consume(71, $input, $state)"/>     <!-- 'in' -->
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-QuantifiedExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse QuantifiedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QuantifiedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 96">                                        <!-- 'some' -->
          <xsl:variable name="state" select="p:consume(96, $input, $state)"/>       <!-- 'some' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(61, $input, $state)"/>       <!-- 'every' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'in' -->
    <xsl:variable name="state" select="p:consume(71, $input, $state)"/>             <!-- 'in' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-QuantifiedExpr-1($input, $state)"/>
    <xsl:variable name="state" select="p:consume(92, $input, $state)"/>             <!-- 'satisfies' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'QuantifiedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleLetBinding.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetBinding" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(8, $input, $state)"/>          <!-- S^WS | ('(' ':') | ':=' -->
    <xsl:variable name="state" select="p:consume(30, $input, $state)"/>             <!-- ':=' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleLetBinding', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleLetClause (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetClause-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(21, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SimpleLetBinding($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleLetClause-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleLetClause.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetClause" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(77, $input, $state)"/>             <!-- 'let' -->
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleLetBinding($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleLetClause-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleLetClause', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse LetExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LetExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleLetClause($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(91, $input, $state)"/>             <!-- 'return' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'LetExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 7">                                         <!-- QName^Token -->
          <xsl:variable name="state" select="p:consume(7, $input, $state)"/>        <!-- QName^Token -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 43">                                        <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:consume(43, $input, $state)"/>       <!-- 'ancestor' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 44">                                        <!-- 'ancestor-or-self' -->
          <xsl:variable name="state" select="p:consume(44, $input, $state)"/>       <!-- 'ancestor-or-self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 45">                                        <!-- 'and' -->
          <xsl:variable name="state" select="p:consume(45, $input, $state)"/>       <!-- 'and' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'cast' -->
          <xsl:variable name="state" select="p:consume(49, $input, $state)"/>       <!-- 'cast' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 50">                                        <!-- 'castable' -->
          <xsl:variable name="state" select="p:consume(50, $input, $state)"/>       <!-- 'castable' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 51">                                        <!-- 'child' -->
          <xsl:variable name="state" select="p:consume(51, $input, $state)"/>       <!-- 'child' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 53">                                        <!-- 'descendant' -->
          <xsl:variable name="state" select="p:consume(53, $input, $state)"/>       <!-- 'descendant' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 54">                                        <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:consume(54, $input, $state)"/>       <!-- 'descendant-or-self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- 'div' -->
          <xsl:variable name="state" select="p:consume(55, $input, $state)"/>       <!-- 'div' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 58">                                        <!-- 'else' -->
          <xsl:variable name="state" select="p:consume(58, $input, $state)"/>       <!-- 'else' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 60">                                        <!-- 'eq' -->
          <xsl:variable name="state" select="p:consume(60, $input, $state)"/>       <!-- 'eq' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 61">                                        <!-- 'every' -->
          <xsl:variable name="state" select="p:consume(61, $input, $state)"/>       <!-- 'every' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 62">                                        <!-- 'except' -->
          <xsl:variable name="state" select="p:consume(62, $input, $state)"/>       <!-- 'except' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 63">                                        <!-- 'following' -->
          <xsl:variable name="state" select="p:consume(63, $input, $state)"/>       <!-- 'following' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 64">                                        <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:consume(64, $input, $state)"/>       <!-- 'following-sibling' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 65">                                        <!-- 'for' -->
          <xsl:variable name="state" select="p:consume(65, $input, $state)"/>       <!-- 'for' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 67">                                        <!-- 'ge' -->
          <xsl:variable name="state" select="p:consume(67, $input, $state)"/>       <!-- 'ge' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 68">                                        <!-- 'gt' -->
          <xsl:variable name="state" select="p:consume(68, $input, $state)"/>       <!-- 'gt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 69">                                        <!-- 'idiv' -->
          <xsl:variable name="state" select="p:consume(69, $input, $state)"/>       <!-- 'idiv' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 72">                                        <!-- 'instance' -->
          <xsl:variable name="state" select="p:consume(72, $input, $state)"/>       <!-- 'instance' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 73">                                        <!-- 'intersect' -->
          <xsl:variable name="state" select="p:consume(73, $input, $state)"/>       <!-- 'intersect' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 74">                                        <!-- 'is' -->
          <xsl:variable name="state" select="p:consume(74, $input, $state)"/>       <!-- 'is' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 76">                                        <!-- 'le' -->
          <xsl:variable name="state" select="p:consume(76, $input, $state)"/>       <!-- 'le' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 77">                                        <!-- 'let' -->
          <xsl:variable name="state" select="p:consume(77, $input, $state)"/>       <!-- 'let' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 78">                                        <!-- 'lt' -->
          <xsl:variable name="state" select="p:consume(78, $input, $state)"/>       <!-- 'lt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 80">                                        <!-- 'mod' -->
          <xsl:variable name="state" select="p:consume(80, $input, $state)"/>       <!-- 'mod' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 81">                                        <!-- 'namespace' -->
          <xsl:variable name="state" select="p:consume(81, $input, $state)"/>       <!-- 'namespace' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 83">                                        <!-- 'ne' -->
          <xsl:variable name="state" select="p:consume(83, $input, $state)"/>       <!-- 'ne' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 86">                                        <!-- 'or' -->
          <xsl:variable name="state" select="p:consume(86, $input, $state)"/>       <!-- 'or' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 87">                                        <!-- 'parent' -->
          <xsl:variable name="state" select="p:consume(87, $input, $state)"/>       <!-- 'parent' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 88">                                        <!-- 'preceding' -->
          <xsl:variable name="state" select="p:consume(88, $input, $state)"/>       <!-- 'preceding' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 89">                                        <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:consume(89, $input, $state)"/>       <!-- 'preceding-sibling' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 91">                                        <!-- 'return' -->
          <xsl:variable name="state" select="p:consume(91, $input, $state)"/>       <!-- 'return' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 92">                                        <!-- 'satisfies' -->
          <xsl:variable name="state" select="p:consume(92, $input, $state)"/>       <!-- 'satisfies' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 95">                                        <!-- 'self' -->
          <xsl:variable name="state" select="p:consume(95, $input, $state)"/>       <!-- 'self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 96">                                        <!-- 'some' -->
          <xsl:variable name="state" select="p:consume(96, $input, $state)"/>       <!-- 'some' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 100">                                       <!-- 'to' -->
          <xsl:variable name="state" select="p:consume(100, $input, $state)"/>      <!-- 'to' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 101">                                       <!-- 'treat' -->
          <xsl:variable name="state" select="p:consume(101, $input, $state)"/>      <!-- 'treat' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(103, $input, $state)"/>      <!-- 'union' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse QName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 46">                                        <!-- 'array' -->
          <xsl:variable name="state" select="p:consume(46, $input, $state)"/>       <!-- 'array' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'attribute' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 52">                                        <!-- 'comment' -->
          <xsl:variable name="state" select="p:consume(52, $input, $state)"/>       <!-- 'comment' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 56">                                        <!-- 'document-node' -->
          <xsl:variable name="state" select="p:consume(56, $input, $state)"/>       <!-- 'document-node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 57">                                        <!-- 'element' -->
          <xsl:variable name="state" select="p:consume(57, $input, $state)"/>       <!-- 'element' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 59">                                        <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:consume(59, $input, $state)"/>       <!-- 'empty-sequence' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 66">                                        <!-- 'function' -->
          <xsl:variable name="state" select="p:consume(66, $input, $state)"/>       <!-- 'function' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 70">                                        <!-- 'if' -->
          <xsl:variable name="state" select="p:consume(70, $input, $state)"/>       <!-- 'if' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 75">                                        <!-- 'item' -->
          <xsl:variable name="state" select="p:consume(75, $input, $state)"/>       <!-- 'item' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 79">                                        <!-- 'map' -->
          <xsl:variable name="state" select="p:consume(79, $input, $state)"/>       <!-- 'map' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 82">                                        <!-- 'namespace-node' -->
          <xsl:variable name="state" select="p:consume(82, $input, $state)"/>       <!-- 'namespace-node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 84">                                        <!-- 'node' -->
          <xsl:variable name="state" select="p:consume(84, $input, $state)"/>       <!-- 'node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 90">                                        <!-- 'processing-instruction' -->
          <xsl:variable name="state" select="p:consume(90, $input, $state)"/>       <!-- 'processing-instruction' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 93">                                        <!-- 'schema-attribute' -->
          <xsl:variable name="state" select="p:consume(93, $input, $state)"/>       <!-- 'schema-attribute' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 94">                                        <!-- 'schema-element' -->
          <xsl:variable name="state" select="p:consume(94, $input, $state)"/>       <!-- 'schema-element' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 97">                                        <!-- 'switch' -->
          <xsl:variable name="state" select="p:consume(97, $input, $state)"/>       <!-- 'switch' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 98">                                        <!-- 'text' -->
          <xsl:variable name="state" select="p:consume(98, $input, $state)"/>       <!-- 'text' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 102">                                       <!-- 'typeswitch' -->
          <xsl:variable name="state" select="p:consume(102, $input, $state)"/>      <!-- 'typeswitch' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'QName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse EQName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-EQName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 5">                                         <!-- URIQualifiedName -->
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- URIQualifiedName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-QName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'EQName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse VarName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-VarName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'VarName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleForBinding.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForBinding" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(42, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'in' -->
    <xsl:variable name="state" select="p:consume(71, $input, $state)"/>             <!-- 'in' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleForBinding', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleForClause (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForClause-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(21, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SimpleForBinding($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleForClause-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleForClause.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForClause" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(65, $input, $state)"/>             <!-- 'for' -->
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleForBinding($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleForClause-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleForClause', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleForClause($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(91, $input, $state)"/>             <!-- 'return' -->
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ExprSingle.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ExprSingle" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 70">                                       <!-- 'if' -->
          <xsl:variable name="state" select="p:lookahead2W(34, $input, $state)"/>   <!-- S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (61,                                          (: 'every' :)
                                         65,                                          (: 'for' :)
                                         77,                                          (: 'let' :)
                                         96)">                                      <!-- 'some' -->
          <xsl:variable name="state" select="p:lookahead2W(40, $input, $state)"/>   <!-- S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') | ')' | '*' |
                                                                                         '+' | ',' | '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' |
                                                                                         '>' | '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 1985">                                      <!-- 'for' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 1997">                                      <!-- 'let' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-LetExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 1981                                          (: 'every' '$' :)
                     or $state[$p:lk] = 2016">                                      <!-- 'some' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-QuantifiedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2118">                                      <!-- 'if' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-IfExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-OrExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ExprSingle', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production Expr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Expr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(21, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-Expr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse Expr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Expr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-Expr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Expr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse XPath.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-XPath" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(11, $input, $state)"/>             <!-- EOF -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'XPath', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Create a textual error message from a parsing error.
   !
   ! @param $input the input string.
   ! @param $error the parsing error descriptor.
   ! @return the error message.
  -->
  <xsl:function name="p:error-message" as="xs:string">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="error" as="element(error)"/>

    <xsl:variable name="begin" select="xs:integer($error/@b)"/>
    <xsl:variable name="context" select="string-to-codepoints(substring($input, 1, $begin - 1))"/>
    <xsl:variable name="linefeeds" select="index-of($context, 10)"/>
    <xsl:variable name="line" select="count($linefeeds) + 1"/>
    <xsl:variable name="column" select="($begin - $linefeeds[last()], $begin)[1]"/>
    <xsl:variable name="expected" select="if ($error/@x or $error/@ambiguous-input) then () else p:expected-token-set($error/@s)"/>
    <xsl:sequence select="
      string-join
      (
        (
          if ($error/@o) then
            ('syntax error, found ', $p:TOKEN[$error/@o + 1])
          else
            'lexical analysis failed',
          '&#10;',
          'while expecting ',
          if ($error/@x) then
            $p:TOKEN[$error/@x + 1]
          else
          (
            '['[exists($expected[2])],
            string-join($expected, ', '),
            ']'[exists($expected[2])]
          ),
          '&#10;',
          if ($error/@o or $error/@e = $begin) then
            ()
          else
            ('after successfully scanning ', string($error/@e - $begin), ' characters beginning '),
          'at line ', string($line), ', column ', string($column), ':&#10;',
          '...', substring($input, $begin, 64), '...'
        ),
        ''
      )
    "/>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consume" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:variable name="begin" select="$state[$p:e0]"/>
        <xsl:variable name="end" select="$state[$p:b1]"/>
        <xsl:variable name="whitespace">
          <xsl:if test="$begin ne $end">
            <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
          </xsl:if>
        </xsl:variable>
        <xsl:variable name="token" select="$p:TOKEN[1 + $state[$p:l1]]"/>
        <xsl:variable name="name" select="if (starts-with($token, &quot;'&quot;)) then 'TOKEN' else $token"/>
        <xsl:variable name="begin" select="$state[$p:b1]"/>
        <xsl:variable name="end" select="$state[$p:e1]"/>
        <xsl:variable name="node">
          <xsl:element name="{$name}">
            <xsl:sequence select="substring($input, $begin, $end - $begin)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, $p:l1, 9),
          0, 0, 0,
          subsequence($state, 13),
          $whitespace/node(),
          $node/node()
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state. In contrast to p:consume, do not create any output.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consumeT" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:sequence select="
          subsequence($state, $p:l1, 9),
          0, 0, 0,
          subsequence($state, 13)
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume whitespace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:whitespace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="end" select="$state[$p:b1]"/>
    <xsl:choose>
      <xsl:when test="$begin eq $end">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="whitespace">
          <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
        </xsl:variable>
        <xsl:sequence select="
          0,
          $state[$p:b0],
          $end,
          subsequence($state, $p:e0 + 1),
          $whitespace/node()
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Use p:match to fetch the next token, but skip any leading
   ! whitespace.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start.
   ! @param $token-set the valid token set id.
   ! @return a sequence of three values: the token code of the result
   ! token, with input string positions of token begin and end.
  -->
  <xsl:function name="p:matchW">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="match" select="p:match($input, $begin, $token-set)"/>
    <xsl:choose>
      <xsl:when test="$match[1] = 8">                                               <!-- S^WS -->
        <xsl:sequence select="p:matchW($input, $match[3], $token-set)"/>
      </xsl:when>
      <xsl:when test="$match[1] = 17">                                              <!-- ('(' ':') -->
        <xsl:variable name="state" select="p:try-Whitespace($input, (0, $begin, $begin, $match, 0, 0, 0, 0, 0, 0, false()))"/>
        <xsl:sequence select="p:matchW($input, $state[$p:e0], $token-set)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$match"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:matchW($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 2 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead2W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l2] ne 0) then
        subsequence($state, $p:l2, 6)
      else
      (
        p:matchW($input, $state[$p:e1], $set),
        0, 0, 0
      )
    "/>
    <xsl:sequence select="
      $match[1] * 128 + $state[$p:l1],
      subsequence($state, $p:b0, 5),
      $match,
      subsequence($state, 13)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 3 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead3W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l3] ne 0) then
        subsequence($state, $p:l3, 3)
      else
        p:matchW($input, $state[$p:e2], $set)
    "/>
    <xsl:sequence select="
      $match[1] * 16384 + $state[$p:lk],
      subsequence($state, $p:b0, 8),
      $match,
      subsequence($state, 13)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:match($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Reduce the result stack, creating a nonterminal element. Pop
   ! $count elements off the stack, wrap them in a new element
   ! named $name, and push the new element.
   !
   ! @param $state lexer state, error indicator, and result.
   ! @param $name the name of the result node.
   ! @param $count the number of child nodes.
   ! @param $begin the input index where the nonterminal begins.
   ! @param $end the input index where the nonterminal ends.
   ! @return the updated state.
  -->
  <xsl:function name="p:reduce" as="item()+">
    <xsl:param name="state" as="item()+"/>
    <xsl:param name="name" as="xs:string"/>
    <xsl:param name="count" as="xs:integer"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>

    <xsl:variable name="node">
      <xsl:element name="{$name}">
        <xsl:sequence select="subsequence($state, $count + 1)"/>
      </xsl:element>
    </xsl:variable>
    <xsl:sequence select="subsequence($state, 1, $count), $node/node()"/>
  </xsl:function>

  <!--~
   ! Parse start symbol XPath from given string.
   !
   ! @param $s the string to be parsed.
   ! @return the result as generated by parser actions.
  -->
  <xsl:function name="p:parse-XPath" as="item()*">
    <xsl:param name="s" as="xs:string"/>

    <xsl:variable name="state" select="0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false()"/>
    <xsl:variable name="state" select="p:parse-XPath($s, $state)"/>
    <xsl:variable name="error" select="$state[$p:error]"/>
    <xsl:choose>
      <xsl:when test="$error">
        <xsl:variable name="ERROR">
          <xsl:element name="ERROR">
            <xsl:sequence select="$error/@*, p:error-message($s, $error)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="$ERROR/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="subsequence($state, $p:result)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

</xsl:stylesheet>
