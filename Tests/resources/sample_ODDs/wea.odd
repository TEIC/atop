<?xml version="1.0" encoding="UTF-8"?>
<!--Processing instructions for the TEI ODDs rng-->
<?xml-model href="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-model href="wea.rng" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:svg="http://www.w3.org/2000/svg"
   xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:math="http://www.w3.org/1998/Math/MathML"
   xmlns:sqf="http://www.schematron-quickfix.com/validator/process"
   xmlns="http://www.tei-c.org/ns/1.0" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xml:id="wea">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>ODD Customization for the Winnifred Eaton Archive Project</title>
            <respStmt>
               <resp>Author</resp>
               <name>Joey Takeda</name>
            </respStmt>
         </titleStmt>
         <publicationStmt>
            <p>Open access?</p>
         </publicationStmt>
         <sourceDesc>
            <p>Born digital. <ptr target="https://github.com/winnifredeatonarchive/wea_data"/></p>
         </sourceDesc>
      </fileDesc>
      <profileDesc>
         <textClass>
            <catRef target="wdt:docBornDigitalDocumentation" scheme="wdt:docType"/>
         </textClass>
      </profileDesc>
      <revisionDesc>
         <change who="pers:JT1" when="2019-03-29">Created file.</change>
         <change when="2022-05-27" resp="ATOP">Added project reference to source description</change>         
      </revisionDesc>
   </teiHeader>
   <text>
      <front>
         <div>
            <head>Introduction</head>
            <p>These are the encoding and technical documentation and guidelines for the Winnifred
               Eaton Archive project. This site is meant to serve as both a record of how the
               project encoded the texts as well as instructions for building and deploying the
               final site.</p>
         </div>
      </front>
      <body>
         <div xml:id="gettingStarted">
            <div xml:id="requirements">
               <head>Requirements</head>
               <p>To edit material for the site, you will need to use a computer with the following
                  software: <list>
                     <item>Git OR SVN (to get data from and commit data to the repository). Most
                        computers come with git automatically installed. To check this, open the
                        Command Line (Windows) / Terminal (Mac/Linux) and type in <code rend="block"
                           >git --version</code>. If you get something like this in response: <code
                           rend="block">git version 2.17.2 (Apple Git-113)</code>, then you have Git
                        installed. Otherwise, follow the instructions <ref
                           target="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git"
                           >here</ref>.</item>
                     <item>Most computers usually come with SVN. See <ref
                           target="http://mapoflondon.uvic.ca/subversion.htm">The Map of Early
                           Modern London</ref>'s documentation on subversion for more information on
                        how to download.</item>
                     <item>oXygen XML Editor. (For current RAs, talk to Mary Chapman about
                        licensing.)</item>
                     <item>You must also set up a free Github account <ref
                           target="https://github.com/">here</ref>. It will be connected to your
                        email address; once the Github account is set up, let the repository owner
                        (currently Joey Takeda) know the email address used so that they can grant
                        you write access to the repository.</item>
                  </list>
               </p>
            </div>
            <div xml:id="svn">
               <head>Using Subversion (for most encoders)</head>
               <p>Most encoders will prefer to use Subversion as the versioning software to interact
                  with the repository. One of the major benefits of using subversion (besides its
                  fairly simple syntax) is the ability to checkout only part of the repository.</p>
               <p>To checkout the WEA data:</p>
               <list>
                  <item>Open the terminal</item>
                  <item>Create a directory for working in: <code rend="block">mkdir wea</code>
                     <emph>Note: If you already have the github repository checked out, you will
                        need to delete the Github verison first.</emph>
                  </item>
                  <item>Go into the directory: <code rend="block">cd wea</code>
                  </item>
                  <item>Checkout the repo:</item>
                  <item>For <emph>encoders</emph>: <code rend="block">svn co
                        https://github.com/winnifredeatonarchive/wea_data/trunk/data .</code>
                  </item>
                  <item>For <emph>developers</emph> (who need the entire codebase): <code
                        rend="block">svn co https://github.com/winnifredeatonarchive/wea_data/trunk/
                        .</code>
                  </item>
                  <item>In both cases: <emph>note the trailing period</emph>!</item>
               </list>
               <div>
                  <head>Updating the repository</head>
                  <p>At the beginning of your work day (and as often as you remember), you should
                        <soCalled>up</soCalled> the repository: <list>
                        <item>Go into your wea directory: <code rend="block">cd wea</code>
                        </item>
                        <item>Then do an svn up: <code rend="block">svn up</code>
                        </item>
                     </list>
                  </p>
               </div>
               <div>
                  <head>Commiting to the repository</head>
                  <p>To commit to the repository, do an <code>svn commit</code> with a message
                     signified by -m and a message contained in quotation marks: <code>svn commit -m
                        "Downloading and encoding SneerNot1.xml"</code>
                  </p>
               </div>
               <div>
                  <head>Guides</head>
                  <p>
                     <list>
                        <item>
                           <ref
                              target="https://mapoflondon.uvic.ca/subversion.htm#subversion_commands"
                              >The MoEML Cheatsheet for Subversion</ref> by Martin Holmes. This
                           table lists the most frequently used commands in subversion.</item>
                     </list>
                     <list>
                        <item>
                           <ref target="http://svnbook.red-bean.com/">SVN Book</ref> by Ben
                           Collins-Sussman, Brian W. Fitzpatrick, and C. Michael Pilato. This is an
                           authorative manual for subversion that is very helpful, but
                           extensive.</item>
                     </list>
                  </p>
               </div>
            </div>
            <div xml:id="github">
               <head>Using Github</head>
               <p>All of the data for the project is kept in a Git repository that is hosted through
                  Github. Git is a version control system, which means that one could <q>roll
                     back</q> the site to any particular version, and retrieve any file at any state
                  of editing. Note that Github is a public repository, so all of the data and commit
                  messages you make are visible to anyone. Our Github repository URL is <ref
                     target="https://github.com/winnifredeatonarchive/wea_data"
                     >https://github.com/winnifredeatonarchive/wea_data</ref>.</p>
               <p/>
               <div xml:id="github_get">
                  <head>Setting up the repository</head>
                  <p>To get the data, you must first checkout a copy of the repository as
                     follows:</p>
                  <list>
                     <item>Open the terminal</item>
                     <item>Create a directory for working in: <code rend="block">mkdir wea</code>
                     </item>
                     <item>Go into the directory: <code rend="block">cd wea</code>
                     </item>
                     <item>Initialize the repository: <code rend="block">git init .</code>
                     </item>
                     <figure>
                        <figDesc>Checkout the repo.</figDesc>

                        <graphic url="../graphics/git_checkout_1.gif"/>
                     </figure>
                     <item>Pull the repository: <code rend="block">git pull
                           https://github.com/winnifredeatonarchive/wea_data</code>
                     </item>
                     <figure>
                        <figDesc>Pull the repo</figDesc>

                        <graphic url="../graphics/git_checkout_2.gif"/>
                     </figure>
                  </list>
                  <p>Note that you only need to do this the first time you start working in the
                     Github repository.</p>
               </div>

               <div xml:id="github_workflow">
                  <head>The Github Workflow</head>
                  <p>The normal workflow for working in Github (and any version software) is as
                     follows: <list>
                        <item>Update your repository so that any changes made by others are pushed
                           into your local system</item>
                        <item>Commit the items to the repository</item>
                        <item>Push those items to the Github interface</item>
                     </list>
                  </p>
                  <div xml:id="github_updating">
                     <head>Updating</head>
                     <p>Make sure to update as often as possible; always update at the beginning of
                        your working session. </p>
                     <list>
                        <item>Go into your working folder: <code rend="block">cd wea</code>
                        </item>
                        <item>Pull the repository: <code rend="block">git pull</code>
                        </item>
                        <figure>
                           <figDesc>Pull the repo.</figDesc>
                           <graphic url="../graphics/git_pull_1.gif"/>
                        </figure>
                     </list>
                  </div>
                  <div xml:id="github_committing">
                     <head>Committing</head>
                     <p>Unlike some versioning systems, Github requires three steps for
                        committing/saving your work to the repository. <list>
                           <item>First, check the status of your files to see what you have changed
                              since your last commit: <code rend="block">git status</code> If there
                              are no changes to the repository, then you'll like see something like
                              this: <code rend="block"> On branch master nothing to commit, working
                                 tree clean </code> If there are changes, you should see something
                              like this: <code rend="block"> On branch master Changes not staged for
                                 commit: (use "git add &lt;file&gt;..." to update what will be
                                 committed) (use "git checkout -- &lt;file&gt;..." to discard
                                 changes in working directory) modified: README.md no changes added
                                 to commit (use "git add" and/or "git commit -a") </code>
                           </item>
                           <figure>
                              <figDesc>Check the status</figDesc>
                              <graphic url="../graphics/git_status_1.gif"/>
                           </figure>
                           <item>If there are changes, then add the files/folders that you want to
                              commit to the repository. <code rend="block">git add
                                 data/texts/My_Title.xml</code>
                           </item>
                           <figure>
                              <figDesc>Add a file</figDesc>
                              <graphic url="../graphics/git_add_1.gif"/>
                           </figure>
                           <item>Third, commit the files to the repository, including a commit
                              message that explains what you did: <code rend="block">git commit -m
                                 "Adding new file."</code>
                           </item>
                           <figure>
                              <figDesc>Commit with a message.</figDesc>
                              <graphic url="../graphics/git_commit_1.gif"/>
                           </figure>
                           <item>Fourth, push the files to the repository: <code rend="block">git
                                 push</code>
                              <figure>
                                 <figDesc>Push the file.</figDesc>
                                 <graphic url="../graphics/git_push_first_1.gif"/>
                              </figure> Note that, if you are committing for the first time, you'll
                              like see something like this: <code rend="block"> Either specify the
                                 URL from the command-line or configure a remote repository using
                                 git remote add &lt;name&gt; &lt;url&gt; and then push using the
                                 remote name git push &lt;name&gt; </code> This means that you must
                              set up your local copy to track the changes in the global repository.
                              To do that, simply follow the above instructions like so: <code
                                 rend="block">git remote add wea
                                 https://github.com/winnifredeatonarchive/wea_data</code>
                              <code rend="block">git push wea</code>
                              <figure>
                                 <figDesc>Remote add.</figDesc>
                                 <graphic url="../graphics/git_remote_add_1.gif"/>
                              </figure> You'll then like get another message, saying something like:
                                 <code rend="block">fatal: The current branch master has no upstream
                                 branch. To push the current branch and set the remote as upstream,
                                 use git push --set-upstream wea master </code> To resolve that,
                              simply: <code rend="block"> git push --set-upstream wea master </code>
                              <figure>
                                 <figDesc>Push the repository.</figDesc>
                                 <graphic url="../graphics/git_push_2.gif"/>
                              </figure> You may then be prompted for your username and password; if
                              this is your first commit, then it might give your instructions on how
                              to store those credentials in your local git system so that you do not
                              need to add your username and password every time you commit. </item>
                        </list>
                     </p>
                  </div>
               </div>
               <div xml:id="github_summary">
                  <head>Github Summary</head>
                  <p>The basic steps for working with Github are: <list>
                        <item>Open a the Terminal or Command Line (on Mac, use the ⌘ + spacebar and
                           type <q>Terminal</q> to find it)</item>
                        <item>Go into your working directory (likely called <q>wea</q>): <code
                              rend="block">cd wea</code>
                        </item>
                     </list> Before you start working: <list>
                        <item>Pull the changes from the repository so that your repository is
                           up-to-date: <code rend="block">git pull</code>
                        </item>
                     </list> While you're working: <list>
                        <item>Save your file (using command/ctrl + S like in MS Word)</item>
                        <item>Validate by pressing the red checkmark button in the toolbar in
                           oXygen</item>
                     </list> Once your file is valid and you want to save the file to the
                     repository: <list>
                        <item>Stage your file to be committed: <code rend="block">git add .</code>
                        </item>
                        <item>Commit your changes: <code rend="block">git commit -m</code>
                        </item>
                        <item>Push your changes to the repository: <code rend="block">git
                              push</code>
                        </item>
                     </list>
                  </p>
               </div>
            </div>

         </div>

         <div xml:id="encoding">
            <head>Instructions for Encoders</head>
            <p>The following instructions are meant to document our encoding practices and provide
               instruction for how to encode different types of documents. Currently, there are
               three types of documents: <list>
                  <item>Databases</item>
                  <item>Primary Sources</item>
                  <item>Born Digital</item>

               </list>
            </p>

            <div xml:id="encodingIntroduction">
               <head>Introduction to the WEA Project</head>
               <div>
                  <head>File Structure</head>
                  <p>The file structure for the full WEA project is as follows: <list
                        style="font-family:monospace">
                        <item>code/</item>
                        <item>data/</item>
                        <item>documentation/</item>
                        <item>lib/</item>
                        <item>notes/</item>
                        <item>sch/</item>
                        <item>site/</item>
                        <item>template/</item>
                        <item>build.xml</item>
                        <item>buildGlobals.xml</item>
                        <item>README.md</item>
                     </list>
                  </p>
                  <p>Most encoders will only need to checkout the data directory, which contains all
                     of the TEI files and images that comprise the main dataset for the WEA project.
                     The folder structure may change over time, but currently it is as follows:
                        <list style="font-family: monospace;">
                        <item>facsimiles/</item>
                        <item>images/</item>
                        <item>info/</item>
                        <item>media/</item>
                        <item>texts/</item>
                        <item>bibliography.xml</item>
                        <item>media.xml</item>
                        <item>organizations.xml</item>
                        <item>people.xml</item>
                        <item>taxonomies.xml</item>
                     </list>
                  </p>
                  <div>
                     <head>
                        <code>facsimiles/</code>
                     </head>
                     <p>The facsimiles directory contains all of the source facsimile images.
                        Currently, we only handle PDFs, but this will likely change in the
                        future.</p>
                     <p>Facsimiles are currently named using underscores separating each word; these
                        names are not necessarily important, but they should be kept consistent for
                        ease of use later.</p>
                  </div>
                  <div>
                     <head>
                        <code>images/</code>
                     </head>
                     <p>The images directory contains the images that are used throughout the site,
                        but are neither a facsimile or a media item (that is, an object described
                        within media.xml). This means that the images directory only contains items
                        that will be used for the site itself and do not constitute a primary object
                        of analysis. </p>
                  </div>
                  <div>
                     <head>
                        <code>info/</code>
                     </head>
                     <p>The info directory contains all of the <q>born-digital</q> documents for the
                        site. This includes biographies, timelines, legal information, et
                        cetera.</p>
                  </div>
                  <div>
                     <head>
                        <code>media/</code>
                     </head>
                     <p>The media directory contains all of the <q>media</q> items, which are not
                        facsimiles of primary sources written by WE, but are included in the media
                        database so that they can be used across the site as related items.</p>
                  </div>
                  <div>
                     <head>
                        <code>texts/</code>
                     </head>
                     <p>The texts directory contains all of the primary source texts, sometimes
                        called <q>objects</q> in this documentation, that comprise the majority of
                        the WEA project. </p>
                  </div>
                  <div>
                     <head>Database files</head>
                     <p>The files that are at the root of this directory (bibliography.xml et
                        cetera) are database files. See the instructions on <ref
                           target="#encodingDatabases">Encoding Databases</ref> for more
                        information.</p>
                  </div>

               </div>
            </div>

            <div xml:id="encodingWorkflow">
               <head>Workflow</head>
               <p>This document describes the basic workflow for encoding a text for the WEA
                  project. In this section, you will find all of the necessary instructions or
                  pointers to instructions for working with a WEA text. These instructions assume
                  that you have already followed the <ref target="#gettingStarted">Getting
                     Started</ref> instructions for setting up your Github repository locally.</p>
               <div>
                  <head>Step 1: Setting up your document</head>
                  <p>Most documents already have a <q>shell</q> document in the /text/ repository;
                     however, if you are adding a new document that was not previously listed in the
                     main bibliography, then you will need to <ref
                        target="#encodingDatabases_bibliography_WE">create a new bibliography
                        entry</ref> and create a new file.</p>
               </div>
               <div>
                  <head>Step 2: Metadata</head>
                  <p/>
               </div>


            </div>


            <div xml:id="encodingDatabases">
               <head>Encoding Databases</head>
               <p>The WEA project consists of three databases for linking entities across the site: <list>
                     <item>Person database (<code>people.xml</code>)</item>
                     <item>Organization datbases (<code>organizations.xml</code>)</item>
                     <item>Bibliography (<code>bibliography.xml</code>)</item>
                  </list>
               </p>
               <div xml:id="encodingDatabases_persons">
                  <head>Encoding People</head>
                  <p>All people featured on the site should be added to the person database. The
                     people in this database include primary people (like Winnifred Eaton, Sara
                     Bosse, and others) as well as contributors (like Mary Chapman, Jean Lee Cole,
                     and others).</p>
                  <div>
                     <head>Basic Rules for Encoding People</head>
                     <p>The basic structure of the people database is a <gi>listPerson</gi> element
                        with a sequence of nested <gi>person</gi> elements. Each <gi>person</gi>
                        element much have an <att>xml:id</att> (usually their initials followed by a
                        number) and a <gi>persName</gi> element. Each <gi>persName</gi> elements
                        must include one of: <list>
                           <item>
                              <gi>forename</gi>: the forename of the person</item>
                           <item>
                              <gi>surname</gi>: the surname of the person</item>
                           <item>
                              <gi>reg</gi>: the regularized name for that person</item>
                        </list>
                     </p>
                     <p>For instance, to create a person named John Smith, you would do the
                        following: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <person xml:id="JS1">
                              <persName>
                                 <forename>John</forename>
                                 <surname>Smith</surname>
                                 <reg>John Smith</reg>
                              </persName>
                           </person>
                        </egXML>
                     </p>

                  </div>
                  <div>
                     <head>Adding Biographical Details</head>
                     <p>Most people should have some sort of biographical details to display both in
                        the info popups as well as to display in each person's dedicated page. To
                        encode biographical details, use the <gi>note</gi> element as a child to the
                           <gi>person</gi> after the <gi>persName</gi>: <egXML
                           xmlns="http://www.tei-c.org/ns/Examples">
                           <person xml:id="JS1">
                              <persName>
                                 <forename>John</forename>
                                 <surname>Smith</surname>
                                 <reg>John Smith</reg>
                              </persName>
                           </person>
                           <note>
                              <p>
                                 <!--Content goes here-->
                              </p> </note>
                        </egXML>
                     </p>
                  </div>
               </div>
               <div xml:id="encodingDatabases_organizations">
                  <head>Encoding Organizations</head>
                  <p>More content coming soon....</p>
               </div>
               <div xml:id="encodingDatabases_bibliography">
                  <head>Encoding the Bibliography</head>
                  <p>The WEA bibliography is a major component of the archive; it contains all of
                     the bibliographic information for each text, with each component tagged and, if
                     appropriate, linked to a centralized entity.</p>
                  <p>The entirety of the bibliography is contained within a single large filed,
                     called <code>bibliography.xml</code>. There are two major <gi>listBibl</gi>
                     elements: the first contains the entire bibliography for works by Winnifred
                     Eaton; the second <gi>listBibl</gi> contains all of the secondary sources used
                     in the born digital documents (i.e. critical articles, scholarly monographs, et
                     cetera). Note that these <gi>listBibl</gi>s are merely organization
                     conveniences and do not have any impact, yet, on the site. This may change in
                     the future, however.</p>

                  <div xml:id="encodingDatabaes_bibliography_styleguide">
                     <head>Bibliographic Style Guidelines</head>
                     <p>The WEA project follows the MLA 8 Guidelines unless otherwise specified.
                        Since we use the <gi>bibl</gi> tag, it is necessary that the proper
                        punctuation and spacing is included within the <gi>bibl</gi>. A few
                        important notes: <list>
                           <item>Do not use <q>np</q> or <q>nd</q> to denote the absence of
                              publishers (or pages) or the absence of dates.</item>
                           <item>Use the abbrevations <q>vol</q>, <q>iss</q>, <q>no</q> to specify
                              volumes, issues, and numbers, respectively.</item>
                        </list>
                     </p>
                  </div>
                  <div xml:id="encodingDatabases_bibliography_WE">
                     <head>The Winnifred Eaton Bibliography</head>
                     <p>The Winnifred Eaton bibliography is encoded using a series of nested
                           <gi>listBibl</gi> elements, each containing a <gi>head</gi> element;
                        these <gi>listBibl</gi>s signify the <term>work</term>. In each of these
                           <gi>listBibl</gi>s are a sequence of <gi>bibl</gi> elements, each
                        containing a manifestation of that work. For instance, <title level="m"
                           >Diary of Delia</title> was both serialized over a period of time as well
                        as appears as a novel. Each instance of this work gets its own <gi>bibl</gi>
                        nested within a <gi>listBibl</gi> like so (the content of these
                           <gi>bibl</gi>s have been excluded, but will be explained in more detail
                        below): <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <listBibl>
                              <head>Diary of Delia</head>
                              <bibl><!--Serial #1--></bibl>
                              <bibl><!--Serial #2--></bibl>
                              <bibl><!--Serial #3--></bibl>
                              <bibl><!--Novel--></bibl>
                           </listBibl>
                        </egXML>
                     </p>

                     <div>
                        <head>Components of a bibl</head>
                        <p>The following outlines the various components of a bibliographic item and
                           how to tag them. While we tag many pieces of a bibliographic item, it is
                           necessary that you include the proper punctuation and spacing as per the
                           MLA 8 guidelines.</p>
                        <div>
                           <head>Authors</head>
                           <p>Tag authors using the <gi>author</gi> tag and use the <gi>name</gi>
                              element with the <att>ref</att> attribute to point to the person
                                 <att>xml:id</att>: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                 <author ref="pers:WE1">Watanna, Onoto</author>. </egXML>
                           </p>
                           <p>Do not include punctuation within the <gi>author</gi> tag and do not
                              regularize the forms of their names.</p>
                           <p>For multiple authors, separate each author with a comma and add a
                              terminal <q>and</q> to the final author: <egXML
                                 xmlns="http://www.tei-c.org/ns/Examples">
                                 <author>
                                    <name ref="pers:WE1">Watanna, Onoto</name>
                                 </author>, and <author>
                                    <name ref="pers:SB1">Sara Bosse</name>
                                 </author>. </egXML>
                           </p>
                           <div>
                              <head>Relational Author Names</head>
                              <p>There are cases where an author's name appears only in relation to
                                 some other work. For instance, in the case of novelized <title
                                    level="m">Marion</title>, the citation is as follows: <cit>
                                    <quote> The author of <hi style="font-style:italic;">Me</hi>,
                                          <hi style="font-style:italic">Marion: The Story of an
                                          Artist’s Model</hi>, <hi style="font-style:italic"
                                          >Herself</hi> and the author of <hi
                                          style="font-style:italic">Me</hi>
                                    </quote>
                                 </cit> From context, we can derive that the first bit (<q>The
                                    author of <hi style="font-style:italic;">Me</hi>, <hi
                                       style="font-style:italic">Marion: The Story of an Artist’s
                                       Model</hi>, <hi style="font-style:italic">Herself</hi>
                                 </q>) refers to Winnifred Eaton and the latter bit refers to Sara
                                 Bosse. In this case, <emph>do not</emph> silently replace or
                                 otherwise regularize these names. Keep them as they appear, and tag
                                 them using the <gi>author</gi> tag. To associate the string to a
                                 person, use the <gi>rs</gi> tag: <specDesc key="rs"/> Use this like
                                 you would the <gi>name</gi> tag, pointing to the person's
                                    <att>xml:id</att> using the <att>ref</att> attribute <egXML
                                    xmlns="http://www.tei-c.org/ns/Examples">
                                    <rs ref="pers:WE1"><!--Content here--></rs>
                                 </egXML> For the above example, we will also want to encode that
                                 the italicized strings are titles; so, in the bibl entry, the
                                 encoding should look like so: <egXML
                                    xmlns="http://www.tei-c.org/ns/Examples">
                                    <author>
                                       <rs ref="pers:WE1">The author of <title level="m">Me</title>,
                                             <title level="m">Marion: The Story of an Artist’s
                                             Model</title>, Herself</rs>
                                    </author> and <rs ref="pers:SB1">the author of <title level="m"
                                          >Me</title>
                                    </rs>
                                 </egXML>
                              </p>
                           </div>
                        </div>
                        <div>
                           <head>Titles</head>
                           <p>Tag all titles using the <gi>title</gi> tag with the appropriate
                                 <att>level</att> attribute: <specDesc key="title" atts="level"/>
                              All monographic titles (i.e. books, etc) should use the
                                 <att>level</att> value <val>m</val>, all journals <val>j</val>, and
                              all articles and other <q>analytic</q> items (poems, short stories,
                              etc) using <val>a</val>. </p>
                           <p>
                              <emph>Note</emph>: For works by Winnifred Eaton, ensure that you wrap
                              each <gi>title</gi>/<att>level</att>=<val>j</val> in the
                                 <gi>publisher</gi> element, with a <att>ref</att> value pointing to
                              the organization described by that journal title. For instance, <egXML
                                 xmlns="http://www.tei-c.org/ns/Examples">
                                 <publisher ref="org:SmartSet">
                                    <title level="j">Smart Set</title>
                                 </publisher>
                              </egXML>
                           </p>
                           <p>Do not include trailing punctuation in either the <gi>title</gi> or
                              the <gi>publisher</gi> element <emph>unless</emph> it is a necessary
                              part of the title (for instance, a question mark).</p>
                        </div>
                        <div>
                           <head>Publishers</head>
                           <p>Tag all publishers using the <gi>publisher</gi> tag with the
                                 <att>ref</att> attribute pointing to the publisher's
                                 <att>xml:id</att> from the organizations database: <egXML
                                 xmlns="http://www.tei-c.org/ns/Examples">
                                 <publisher ref="org:Harper">Harper and Brothers</publisher>
                              </egXML>
                           </p>
                           <p>As stated above, wrap all
                              <gi>title</gi>/<att>level</att>=<val>j</val>s in the
                                 <gi>publisher</gi> element, since we consider the journal as a
                              reference to the larger publication house. In future, we hope to group
                              all of the journal publishers into larger lists, in cases where one
                              large publishing house conglomerates a number of distinct publishing
                              entities.</p>
                        </div>

                        <div>
                           <head>Volumes, Issues, and Page Ranges</head>
                           <p>Tag all volumes, issues (also called numbers), and page ranges using
                              the <gi>biblScope</gi> element with the appropriate <att>unit</att>:
                                 <specDesc key="biblScope" atts="unit"/> For instance: <egXML
                                 xmlns="http://www.tei-c.org/ns/Examples"> vol. <biblScope
                                    unit="volume">30</biblScope>, no. <biblScope unit="issue"
                                    >2</biblScope>, pp. <biblScope unit="page">76-78,
                                    117-118</biblScope>
                              </egXML> Do not denote the absence of volumes, issues, or page ranges
                              by using <q>n.p</q> or an equivalent. </p>
                        </div>
                        <div>
                           <head>Publication Dates</head>
                           <p>Encode the date of publication using the <gi>date</gi> element. The
                                 <gi>date</gi> element is a special case where we <emph>do
                                 not</emph> include text in the <gi>date</gi> element. Instead, use
                              the dating attributes provided by the <gi>date</gi> element: <specDesc
                                 key="date" atts="notBefore notAfter when to from"/> All of these
                              dating attributes require a date in the format: YYYY[-MM[-DD]]. In
                              other words, the following are <emph>acceptable</emph>: <list>
                                 <item>1999</item>
                                 <item>1901-12</item>
                                 <item>1903-11-04</item>
                              </list> The following are <emph>unacceptable</emph>: <list>
                                 <item>1999/12/01</item>
                                 <item>1999-23</item>
                                 <item>-21</item>
                                 <item>21 March 1904</item>
                              </list>
                           </p>
                           <p>In most cases, the <att>when</att> attribute with suffice for encoding
                              the date of publication: <egXML
                                 xmlns="http://www.tei-c.org/ns/Examples">
                                 <date when="1901-12-13"/>
                              </egXML>
                              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                 <date when="1901"/>
                              </egXML> However, there are often cases where the date of publication
                              is difficult to determine. In these cases use <att>notBefore</att>,
                                 <att>notAfter</att>, and, optionally, the <att>cert</att>
                           </p>
                           <p>For instance, the case of certain date ranges (i.e. I know that this
                              had to be published between 1922-1924) would be encoded as follows:
                                 <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                 <date notBefore="1922" notAfter="1924"/>
                              </egXML> If you know the decade in which something is published, then
                              encode it as follows: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                 <date notBefore="1900" notAfter="1909"/>
                              </egXML> If you are uncertain about the date range, then use the
                                 <att>cert</att> attribute with the values of either <val>low</val>
                              or <val>medium</val> to denote your certainty about this date: <egXML
                                 xmlns="http://www.tei-c.org/ns/Examples">
                                 <date notBefore="1902" notAfter="1911" cert="low"/>
                              </egXML>
                           </p>
                        </div>
                        <div>
                           <head>Manuscript Locations</head>
                           <p>If an object exists only in manuscript, then record the location of
                              the manuscript using the <gi>distributor</gi> element and, if
                              applicable, the <gi>idno</gi> element. In most cases, this will be an
                              entry in the Winnifred Eaton Reeve fonds at the University of
                              Calgary.</p>
                           <p>Use the <gi>distributor</gi> element to denote the archive in
                              question: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                 <distributor>Winnifred Eaton Reeve Fonds</distributor>
                              </egXML> . Use the <gi>idno</gi> to encode any archival identification
                              numbers: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                 <idno>3.2.5</idno>
                              </egXML>
                           </p>
                        </div>

                     </div>

                  </div>
               </div>
            </div>
            <div xml:id="creatingNewText">
               <head>Creating a New Text</head>
               <p>Most of the WE texts already have shell files in the texts/ folder. If the text
                  already exists in the bibliography and exists in the /texts/ folder, but you want
                  to add the transcription from Google Drive, following the Adding Transcription
                  instructions. Otherwise, following the Adding a New Text instructions below.</p>
               <div xml:id="creatingNewTextFromScratch">
                  <head>Adding a New Text</head>
                  <p>In order for a new text to be added to the WEA, each text must have two
                     necessary components: a bibliographic item in the bibliography file
                     (bibliography.xml) and a corresponding file for the transcription in
                     /data/texts.</p>
                  <p>Note that all of these instructions assume that you have the WEA project file
                     (wea_data.xpr) project open in oXygen. I.e. in the left pane of oXygen, you
                     should see something at the top that says wea_data.xpr.</p>
                  <div>
                     <head>Step 1: Add to the bibliography</head>
                     <div>
                        <head>Step 1a: Create a new work</head>
                        <p>Depending on the new text, you may need to create a new <q>work</q> for
                           the bibliographic item. The idea here is that each individual instance of
                           a text (i.e. something that <emph>actually</emph> exists in some printed
                           form) is related to a more abstract notion of the <q>work</q>. For
                           instance, we have three different version of <title level="m"
                              >Cattle</title> in the project: these are more-or-less the same, but
                           contain some significant differences that we want to capture in the
                           project. Another example is a text like <title level="m">Marion</title>,
                           which is a serialized novel: each individual serialized chapter and the
                           novel itself all relate to the abstract notion of a text called <title
                              level="m">Marion</title>.</p>
                        <p>What this means is that the bibliography is structured in such a way so
                           that each text is related to its corresponding work via a
                              <gi>listBibl</gi>. An example from <title level="m">Cattle</title>:
                              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                              <listBibl xml:id="Cattle">
                                 <head>Cattle</head>
                                 <bibl xml:id="bibl36"><author><name ref="pers:WE1">Eaton,
                                          Winnifred</name> (<name ref="pers:WE1">Watonna,
                                          Onota</name>)</author>. <title level="m">Cattle</title>.
                                       <pubPlace>New York</pubPlace>, <publisher ref="org:Watt">W.J.
                                       Watt</publisher>, <date when="1924">1924</date>.</bibl>
                                 <bibl xml:id="bibl221"><author><name ref="pers:WE1">Watanna,
                                          Onoto</name></author>. <title level="m">Cattle</title>.
                                       <pubPlace>Toronto</pubPlace>, <publisher ref="org:Musson"
                                       >Musson</publisher>, <date when="1923">1923</date>.</bibl>
                                 <bibl xml:id="bibl222"><author><name ref="pers:WE1">Watanna,
                                          Onoto</name></author>. <title level="m">Cattle</title>.
                                       <pubPlace>London</pubPlace>, <publisher ref="org:Hutchinson"
                                       >Hutchinson</publisher>, <date when="1923"
                                    >1923</date>.</bibl>
                              </listBibl>
                           </egXML>
                        </p>
                        <p>Each work gets a <gi>listBibl</gi> in the we_bibliography
                              <gi>listBibl</gi>. The <att>xml:id</att> for that bibliographic entry
                           is whatever you think the text file should be called without the number
                           (so, here <val>Cattle</val>, which then corresponds with files in
                           /texts/: Cattle1.xml, Cattle2.xml, and Cattle3.xml). Note that the
                              <gi>bibl</gi> xml:ids do not match the file names and they are not
                           necessarily in sequence; that's addressed in the next step.</p>
                        <p>For now, though, if you are adding a new item to the WEA, you must first
                           check whether or not the <q>work</q> exists. Usually this will the case
                           if a new instance of a text (like a serialized novel) has been
                           discovered. If you are adding a new text to a pre-existing work, then you
                           can skip to the next step.</p>
                        <p>Otherwise, you must create a new work in the bibliography. To do so, find
                           an appropriate place (alphabetically) in bibliography.xml where you can
                           add your work and then create a new listBibl for it. If we were adding a
                           new like called <q>Cars are Bad</q>, we would do something like this
                           (note: it doesn't really matter where you end up putting it so long as
                           it's within the wea_bibliography): <egXML
                              xmlns="http://www.tei-c.org/ns/Examples">
                              <listBibl xml:id="CarsAreBad">
                                 <head>Cars Are Bad</head>
                              </listBibl>
                           </egXML>
                        </p>
                        <p>Note that there are two necessary things here: the <att>xml:id</att> and
                           the <gi>head</gi> element: the <gi>head</gi> element is the title for the
                           work; the <att>xml:id</att> is the id for the entire work and should
                           correspond with the base id of the new text (i.e. in this instance,
                           CarsAreBad1.xml). Note that this will also be the URL of the document, so
                           try and be consistent with the rest of the texts regarding leading
                           articles, et cetera.</p>
                     </div>


                     <div>
                        <head>Step 1b: Adding a new bibliographic entry</head>
                        <p>To add a new bibliographic entry to a work, first add a <gi>bibl</gi>
                           element after the <gi>head</gi> like so: <egXML
                              xmlns="http://www.tei-c.org/ns/Examples">
                              <listBibl xml:id="CarsAreBad">
                                 <head>Cars Are Bad</head>
                                 <bibl><!--Content goes here--></bibl>
                              </listBibl>
                           </egXML>
                        </p>

                        <p>oXygen will be mad at you: that's OK and expected. Click on the red
                           underlined <gi>bibl</gi> tag. You should now see a little red lightbulb
                           beside the <gi>bibl</gi> element. Click on the lightbulb and you should
                           see a box that says something like <q>Add a new bibl id</q>. Click on
                           that (or press enter). With any luck, you should then get a properly
                           formed bibl <att>xml:id</att>, which will look something like so: <egXML
                              xmlns="http://www.tei-c.org/ns/Examples">
                              <listBibl xml:id="CarsAreBad">
                                 <head>Cars Are Bad</head>
                                 <bibl xml:id="bibl232"><!--Content goes here--></bibl>
                              </listBibl>
                           </egXML>
                        </p>

                        <p>Next, add the details to the bibliography following the <ref
                              target="#encodingDatabases_bibliography_WE">style guidelines
                              here</ref>. Once all of that information has been filled in, you
                           should have a bibl that looks something like this: <egXML
                              xmlns="http://www.tei-c.org/ns/Examples">
                              <listBibl xml:id="CarsAreBad">
                                 <head>Cars Are Bad</head>
                                 <bibl xml:id="bibl232"><author><name ref="pers:WE1">Reeve,
                                          Winnifred</name></author>. <title level="a">Cars Are
                                       Bad</title>. <publisher ref="org:CdnBookman"><title level="j"
                                          >Canadian Bookman</title></publisher>, vol. <biblScope
                                       unit="volume">1</biblScope>, no. <biblScope unit="issue"
                                       >1</biblScope>, <date when="1920-02">Feb. 1920</date>, pp.
                                       <biblScope unit="page">140-147</biblScope>.</bibl>
                              </listBibl>
                           </egXML>
                        </p>
                     </div>
                  </div>
                  <div>
                     <head>Step 2: Generating a New Document</head>
                     <p>Once you've created a new bibl entry, you can add a new shell for that
                        document.</p>
                     <p>To do so, open the document addTextsFromBibl.html from your oXygen menu; it
                        should be below addTextFromDrive.xml</p>
                     <p>Next, click the red play button at the top of the document. </p>
                     <p>After a few seconds, you should see something at the bottom of your screen
                        that says which new documents were created. If you created a new work, then
                        you'd see something like <q>Creating CarsAreBad1 from bibl232</q>.</p>
                     <p>If that's successful, then you can go into the /texts/ folder and find your
                        document. You may need to right-click and click refresh on /texts/ directory
                        in your oXygen project pane.</p>
                     <p>Open that document and make any of the necessary metadata changes: adding
                        proper category references and metadata primarily.</p>
                     <p>Once the file is valid and has all of the appropriate metadata, make sure to
                           <code>svn add</code> your document to the repo: <code rend="block">svn
                           add texts/CarsAreBad1.xml</code>
                        <code rend="block">svn commit -m "Adding new CarsAreBad file from new bibl
                           entry"</code>
                     </p>
                  </div>
               </div>
               <div xml:id="createNewTextTranscription">
                  <head>Adding Transcription</head>
                  <p>To add a new transcription from the Google Drive, go to the file
                     addTextFromDrive.xml in your oXygen project pane on the left and follow the
                     instructions there.</p>
               </div>

            </div>
            <div xml:id="encoding_primary">
               <head>Encoding a Primary Source Document</head>
               <p>Below are abbreviated discussions on how to encode various features of a text</p>
               <div xml:id="encoding_primary_structure">
                  <head>Structure</head>
                  <p>All content of the texts goes into the <gi>body</gi> element. Surround all
                     content with a <gi>div</gi> element like so: <egXML
                        xmlns="http://www.tei-c.org/ns/Examples">
                        <body>
                           <!--Front matter goes here-->
                           <div>
                              <!--Content goes here-->
                           </div>
                        </body>
                     </egXML>
                  </p>
                  <p>Individual sections can be encoded using nested <gi>div</gi> tags, if desired:
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <body>
                           <head>A Poor Devil</head>
                           <opener>
                              <opener>
                                 <byline>By <name ref="pers:WE">Winnie Eaton</name>,
                                    Montreal.</byline>
                                 <note>[Written for the Metropolitan.]</note>
                              </opener>
                           </opener>
                           <div>

                              <div>
                                 <!--Section 1-->
                                 <div>
                                    <!--Section 1.1-->
                                 </div>
                                 <div>
                                    <!--Section 1.2-->
                                 </div>
                              </div>
                              <div>
                                 <!--Section 2-->
                              </div>
                           </div>
                        </body>
                     </egXML>
                  </p>
               </div>
               <div xml:id="encoding_primary_facsimiles">
                  <head>Associating facsimiles</head>
                  <p>All primary source documents should have a related facsimile associated with
                     the document. To do so, simply ensure that the PDF has been added to the
                        <code>data/facsimiles/</code> directory with a filename that follows the
                     rules for filenaming discussed above (no spaces, underscores, et cetera).</p>
                  <p>To associate the primary source document with the facsimile, use the
                        <att>facs</att> attribute on the <gi>text</gi> element, with a pointer to
                     the facsimile's file name using the private <q>facs:</q> URI scheme: <egXML
                        xmlns="http://www.tei-c.org/ns/Examples">
                        <text facs="facs:Three_Loves_Puritan">
                           <!--Content here-->
                        </text>
                     </egXML>
                  </p>
               </div>
               <div xml:id="encoding_primary_openerCloser">
                  <head>Openers and Closers</head>
                  <p>Most of the texts have some sort of header or closer with the author's name,
                     date of publication, et cetera. Use the <gi>opener</gi> element if this occurs
                     at the beginning of the text and the <gi>closer</gi> element if it is at the
                     bottom.</p>
               </div>
               <div xml:id="encoding_primary_bylines">
                  <head>Bylines</head>
                  <p>If there is an authorial statement of responsibility of some sort, enclose this
                     in a <gi>byline</gi> element. Tag Winnifred Eaton's name (in whatever
                     psuedonymic form it appears) with the <gi>name</gi> tag with an <att>ref</att>
                     value of <val>pers:WE1</val>.</p>
               </div>
               <div xml:id="encoding_primary_gaps">
                  <head>Gaps and omissions</head>
                  <p>If the text cannot be transcribed for some reason (damage, etc), then use the
                        <gi>gap</gi> element to signify that there is a gap in transcription: <egXML
                        xmlns="http://www.tei-c.org/ns/Examples">
                        <gap reason="damaged"/>
                     </egXML>
                  </p>
                  <p>If you can supply the damaged text, use the <gi>supplied</gi> element instead
                     with an <att>resp</att> value pointing to your <att>xml:id</att> (which is
                     usually your initials): <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <supplied resp="pers:JT1">ed</supplied>
                     </egXML>
                  </p>
                  <p>You can encode how certain you are of your editorial addition by using the
                        <att>cert</att> attribute on supplied with a value of <q>low</q>
                     <q>medium</q> or <q>high</q>. If no <att>cert</att> is supplied, it is assumed
                     that it has a high value of certainty: <egXML
                        xmlns="http://www.tei-c.org/ns/Examples">
                        <supplied resp="pers:JT" cert="low">ed</supplied>
                     </egXML>
                  </p>
               </div>
               <div xml:id="encoding_editorial_fixes">
                  <head>Encoding Editorial Fixes</head>
                  <p>Occassionally, a word or phrase will be obviously incorrect and should be
                     changed for readability's sake. In these instances, use the <gi>choice</gi>
                     element with <gi>sic</gi> and <gi>corr</gi>, like so (example taken from Poor
                     Devil): <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <p><!--[...]--> who does the book-keeping, assists the typewriter, <choice>
                              <sic>goes</sic>
                              <corr>does</corr>
                           </choice> messages, and after giving ten years of his precious life to
                           one firm actually receives the magnificent sum of $10 per week!</p>
                     </egXML>
                  </p>

                  <p>Note that you must supply <emph>both</emph>
                     <gi>sic</gi> and <gi>corr</gi> in that order; usually these emendations will be
                     supplied by the Project Director.</p>
               </div>

               <div xml:id="encoding_abbrevations">
                  <head>Abbreviations and Expansions</head>
                  <p>To aid reading, we expand common abbreviations using the <gi>choice</gi>
                     element in combination with <gi>abbr</gi> and <gi>expan</gi>. Use the
                        <gi>abbr</gi> element to tag the abbreviation, and the <gi>expan</gi>
                     element for the expansion: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <p>[. . .] I was a smart set, however, for my father was a <choice>
                              <abbr>Q. C.</abbr>
                              <expan>Queens Councel</expan>
                           </choice> and <choice>
                              <abbr>M. P.</abbr>
                              <expan>Member of Parliament</expan>
                           </choice>
                        </p>
                     </egXML> Note that we <emph>do not</emph> tag expansions that could be
                     abbreviated; only tag instances in the primary source where an abbreviation
                     could be helpful expanded into a full sequence of words. </p>
               </div>

               <div xml:id="encoding_primary_quotations">
                  <head>Quotations</head>
                  <p>Currently, we do not distinguish between various types of quotations--direct
                     speech, indirect speech, titles, et cetera. Instead, we simply use the
                        <gi>q</gi> element: <specDesc key="q"/>
                  </p>
                  <p>To encode quotations, first follow the quick fixes that are keyed to the body
                     of your document. Right click the <gi>body</gi> element of your file, and you
                     should see a red lightbulb. It should give you options to perform a set of
                     automated fixes for your file.</p>

                  <div xml:id="encoding_primary_quotaions_block">
                     <head>Block quotations</head>
                     <p>To tag block quotations, simply use the <gi>q</gi> element with a <gi>p</gi>
                        within it. If it's a block quotation that contains verse, for instance, use
                        the <gi>lg</gi> element (or whatever is the most appropriate for the case):
                           <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <q>
                              <lg>
                                 <l>The summer days are coming</l>
                                 <l>The blossoms deck the bough,</l>
                                 <l>The bees are gaily humming</l>
                                 <l>And the birds are singing now.</l>
                              </lg>
                           </q>
                        </egXML>
                     </p>
                  </div>
                  <div xml:id="encoding_primary_quotations_letters">
                     <head>Letters as Quotations and Other Interrupting Texts</head>
                     <p>Often, especially in the novels, letters appear within the regular narrative
                        flow of the text. To handle this, we use the <gi>floatingText</gi> element:
                           <specDesc key="floatingText"/> The <gi>floatingText</gi> element can
                        contain everything a regular <gi>text</gi> element can, and so we can use
                        the appropriate encoding to handle the interrupting texts. </p>
                     <p>Most commonly, <gi>floatingText</gi> will be used in combination with
                           <gi>q</gi> to handle letters. To encode the letters, we use the specific
                        elements for encoding letters per the TEI: <specDesc key="salute"/>
                        <specDesc key="signed"/>
                     </p>
                     <p>To encode a letter, first wrap the letter in a <gi>q</gi>, then a
                           <gi>floatingText</gi> with an <att>type</att>=<val>letter</val>, and then
                        a <gi>body</gi> element. <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <q>
                              <floatingText type="letter">
                                 <body>
                                    <!--Content of the letter goes here-->
                                 </body>
                              </floatingText>
                           </q>
                        </egXML>
                     </p>
                     <p>Most often, letters will contain opening and closing matter; often this is a
                        salute (a salutation) or some signature. These are tagged using the
                           <gi>salute</gi> and <gi>signed</gi> elements, wrapped in <gi>opener</gi>
                        and <gi>closer</gi> tags. An example to illustrate: <egXML
                           xmlns="http://www.tei-c.org/ns/Examples">
                           <q>
                              <floatingText type="letter">
                                 <body>
                                    <opener>
                                       <salute>Darling Girlie:</salute>
                                    </opener>

                                    <p>I am counting the hours when I will be with you. I tried to
                                       get up to see you last night, but it was impossible. Lord
                                       Eaton’s son, young Albert, was on the steamer coming over,
                                       and they are friends of the governor’s and I simply had to be
                                       with them. You see, darling, it means a good deal to me in
                                       the future, to be in touch with these people. His
                                       brother-in-law, whom I met last night, is head cockalorum in
                                       the House of Parliament, and as I have often told you, my
                                       ambition is to get into politics. It’s the surest road to
                                       fame for a Barrister.</p>

                                    <p>Now I hope my foolish little girl will understand and believe
                                       me when I say that I am thinking for you as much as for
                                       myself.</p>

                                    <p>I am hungry for a kiss, and I feel I cannot wait till
                                       tonight.</p>

                                    <closer>
                                       <salute>Your own,</salute>
                                       <signed>Reggie.</signed>
                                    </closer>
                                 </body>
                              </floatingText>
                           </q>
                        </egXML>
                     </p>
                     <p>Note that occassionally the letter is interrupted by authorial/narrative
                        commentary; we do not respect the quotation mark boundaries, but rather
                        encode these interruptions as authorial notes. To tag these, use the
                           <gi>note</gi> element with an <att>type</att>=<val>authorial</val>
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <q>
                              <floatingText type="letter">
                                 <body>
                                    <opener>
                                       <salute>Dear Miss Marion:</salute>
                                    </opener>



                                    <p>Will you and your charming sister take a little drive with me
                                       and a friend this evening? If so, meet us at eight o’clock,
                                       corner of St. James and St. Denis streets. My friend has seen
                                       your sister in Judge Laflamme’s office <note type="authorial"
                                          >(Ellen worked there)</note> and he is very anxious to
                                       know her. As for me, I am thinking only of when I shall see
                                       my lovely rose again. I am counting the hours!</p>

                                    <closer>
                                       <salute>Devotedly,</salute>
                                       <signed>Fred Stevens.</signed>
                                    </closer>
                                 </body> </floatingText>
                           </q>
                        </egXML>
                     </p>
                  </div>
                  <div xml:id="encoding_primary_quotations_hierarchies">
                     <head>Quotations across hierarchies</head>
                     <p>Particularly in novels, quotations will appear across hierarchies; that is,
                        a quotation will start on one page, be interrupted by content on another
                        page, and then continue on the following page. Take, for instance, this
                        example from <title level="m">Marion</title>: <code rend="block"> “It isn’t
                           as if they are strangers, you know. One of them, Harry Bond, is my own
                           fellow. You know who his folks are, and but for them we’d have been
                           married long ago. Well, Harry’s friend, the one who wants to meet you, is
                           a swell, too, and he hasn’t been out from England long. Harry says his
                           folks are big nobs over there, and [Image unavailable.] Someone had
                           passed up to me over the footlights, if you please, a real bouquet of
                           flowers. he is studying law here. His folks send him a remittance and I
                           guess it’s a pretty big one, for he’s living at the Windsor, and I guess
                           he can treat us fine. So come along. You’ll not get such a chance again.”
                        </code> Here, the quotation properly starts at in the first paragraphic
                        block and is then interrupted by an image insert between the pages, and then
                        continues afterwards. To deal with this overlapping hierarchy, there are two
                        steps we must take: <list>
                           <item>First, we must signal that the paragraph before the image inserts
                              is the same paragraph as the one after</item>
                           <item>Second, we must signal that the continue continues across the page
                              hierarchy, but does not include the image (of course, the image is not
                              part of the quoted material).</item>
                        </list>
                     </p>

                     <p>To signal the paragraphs continuation, we use the <att>part</att> attribute:
                           <specDesc key="p" atts="part"/> We use the value <val>I</val> to signal
                        the initial paragraph, <val>M</val> to signal any medial paragraphs, and
                           <val>F</val> to signal the final paragraph. <egXML
                           xmlns="http://www.tei-c.org/ns/Examples">
                           <p part="I">It isn’t as if they are strangers, you know. One of them,
                              Harry Bond, is my own fellow. You know who his folks are, and but for
                              them we’d have been married long ago. Well, Harry’s friend, the one
                              who wants to meet you, is a swell, too, and he hasn’t been out from
                              England long. Harry says his folks are big nobs over there, and</p>
                           <pb n="48.1" xml:id="page_48.1"/>
                           <figure>
                              <graphic url="images/i_061_sml.jpg"/>
                              <p>Someone had passed up to me over the footlights, if you please, a
                                 real bouquet of flowers.</p>
                           </figure>
                           <pb n="49" xml:id="page_49"/>
                           <p part="F">he is studying law here. His folks send him a remittance and
                              I guess it’s a pretty big one, for he’s living at the Windsor, and I
                              guess he can treat us fine. So come along. You’ll not get such a
                              chance again.</p>
                        </egXML>
                     </p>

                     <p>To handle the overlapping quotations, we use a similar approach using the
                           <att>next</att> and <att>prev</att> attributes to signal explicitly the
                        sequence of quotation elements: <specDesc key="q" atts="next prev"/>
                     </p>
                     <p>To do so, we must first give each <gi>q</gi> an <att>xml:id</att>; this can
                        be whatever you want, but it usually makes most sense to prefix it with the
                        file's name and use a sensible numbering system: <egXML
                           xmlns="http://www.tei-c.org/ns/Examples">
                           <q xml:id="Marion_q1">It isn’t as if they are strangers, you know. One of
                              them, Harry Bond, is my own fellow. You know who his folks are, and
                              but for them we’d have been married long ago. Well, Harry’s friend,
                              the one who wants to meet you, is a swell, too, and he hasn’t been out
                              from England long. Harry says his folks are big nobs over there,
                              and</q>
                        </egXML> We do the same thing for the second quotation element, giving it an
                           <att>xml:id</att>: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <q xml:id="Marion_q2" prev="#Marion_q1">he is studying law here. His
                              folks send him a remittance and I guess it’s a pretty big one, for
                              he’s living at the Windsor, and I guess he can treat us fine. So come
                              along. You’ll not get such a chance again</q>. </egXML> We then use
                        the <att>next</att> and <att>prev</att> attributes to point to each
                        quotation in the sequence. <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <q xml:id="Marion_q1" next="#Marion_q2">It isn’t as if they are
                              strangers, you know. One of them, Harry Bond, is my own fellow. You
                              know who his folks are, and but for them we’d have been married long
                              ago. Well, Harry’s friend, the one who wants to meet you, is a swell,
                              too, and he hasn’t been out from England long. Harry says his folks
                              are big nobs over there, and</q>
                           <!--Stuff-->
                           <q xml:id="Marion_q2" prev="#Marion_q1">he is studying law here. His
                              folks send him a remittance and I guess it’s a pretty big one, for
                              he’s living at the Windsor, and I guess he can treat us fine. So come
                              along. You’ll not get such a chance again</q>. </egXML> So, putting it
                        all together: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <p part="I">
                              <q xml:id="Marion_q1" next="#Marion_q2">It isn’t as if they are
                                 strangers, you know. One of them, Harry Bond, is my own fellow. You
                                 know who his folks are, and but for them we’d have been married
                                 long ago. Well, Harry’s friend, the one who wants to meet you, is a
                                 swell, too, and he hasn’t been out from England long. Harry says
                                 his folks are big nobs over there, and</q>
                           </p>
                           <pb n="48.1" xml:id="page_48.1"/>
                           <figure>
                              <graphic url="images/i_061_sml.jpg"/>
                              <p>Someone had passed up to me over the footlights, if you please, a
                                 real bouquet of flowers.</p>
                           </figure>
                           <pb n="49" xml:id="page_49"/>
                           <p part="F">
                              <q xml:id="Marion_q2" prev="#Marion_q1">he is studying law here. His
                                 folks send him a remittance and I guess it’s a pretty big one, for
                                 he’s living at the Windsor, and I guess he can treat us fine. So
                                 come along. You’ll not get such a chance again</q>.</p>
                        </egXML>
                     </p>


                  </div>
               </div>
               <div xml:id="codeTemplates">
                  <head>Code Templates (Shortcuts)</head>
                  <p>The table below lists keyboard shortcuts for inserting common encoding features
                     in a text. In most cases, the code template simply requires selecting (i.e.
                     highlighting) the bit of text you want to encode and then typing in the
                     keystroke; the exception currently is the gap element shortcut, which is simply
                     inserted where your cursor is in the document.</p>

                  <table>
                     <row>
                        <cell>M1</cell>
                        <cell>Command key on MacOS X, Ctrl on other platforms.</cell>
                     </row>
                     <row>
                        <cell>M2</cell>
                        <cell>Shift</cell>
                     </row>
                     <row>
                        <cell>M3</cell>
                        <cell>Option on Mac OS X, Alt on other platforms</cell>
                     </row>
                  </table>
                  <table xml:id="codeTemplates_table">
                     <row role="label">
                        <cell>Name</cell>
                        <cell>Description</cell>
                        <cell>Result</cell>
                        <cell>Keystroke</cell>
                     </row>
                     <row>
                        <cell>Insert left quotation mark</cell>
                        <cell>Insert the the opening curly quotation mark</cell>
                        <cell>
                           <code>“</code>
                        </cell>
                        <cell>M1 M2 L</cell>
                     </row>
                     <row>
                        <cell>Insert left single quote</cell>
                        <cell>Inserts the opening single curly apostrophe</cell>
                        <cell>
                           <code>‘</code>
                        </cell>
                        <cell>M1 M2 A</cell>
                     </row>
                     <row>
                        <cell>Insert right curly quote</cell>
                        <cell>Inserts the closing curly quotation mark</cell>
                        <cell>
                           <code>”</code>
                        </cell>
                        <cell>M1 M2 R</cell>
                     </row>
                     <row>
                        <cell>Tag foreign</cell>
                        <cell>Tag a foreign selection</cell>
                        <cell>
                           <code>&lt;foreign&gt;${selection}&lt;/foreign&gt;</code>
                        </cell>
                        <cell>M1 M2 F</cell>
                     </row>
                     <row>
                        <cell>Tag gap</cell>
                        <cell>Insert a gap element</cell>
                        <cell>
                           <code>&lt;gap reason="${caret}"/&gt;</code>
                        </cell>
                        <cell>M1 M2 G</cell>
                     </row>
                     <row>
                        <cell>Tag paragraph</cell>
                        <cell>Tag a paragraph</cell>
                        <cell>
                           <code>&lt;p&gt;${selection}&lt;/p&gt;</code>
                        </cell>
                        <cell>M1 M2 P</cell>
                     </row>
                     <row>
                        <cell>Tag Winnifred Eaton's name</cell>
                        <cell>Tag a reference to Winnifred Eaton</cell>
                        <cell>
                           <code>&lt;name ref="pers:WE1"&gt;${selection}&lt;/name&gt;</code>
                        </cell>
                        <cell>M1 M2 W</cell>
                     </row>
                  </table>

               </div>
            </div>

            <div xml:id="encoding_bornDigital">
               <head>Encoding Born Digital Documents</head>
               <p>Born digital documents are documents that are not primary sources (i.e. not texts)
                  and whose contents were written for the purpose of the site: this includes
                  documents like essays, exhibit pages, the home page, et cetera.</p>
               <div>
                  <head>Editing the Home Page</head>
                  <p>All of the content for the home page can be found in
                        <code>info/index.xml</code>; note that the structure of this page does not
                     determine the final order of objects as they appear on the home page. There is
                     specialized processing for the home page, which is embedded within
                     code/xsl/xhtml_index_module.xsl.</p>
                  <div>
                     <head>Editing the <q>Hero Image</q> Text</head>
                     <p>The text that overlays the <q>hero image</q> (the big banner image of
                        Winnifred Eaton) is encoded in the <code>div/@xml:id='index_header'</code>.
                        It currently looks like this: <egXML
                           xmlns="http://www.tei-c.org/ns/Examples">
                           <div xml:id="index_header">
                              <div>
                                 <head>The Winnifred Eaton Archive</head>
                                 <head type="subtitle">Romancer — Journalist — Screenwriter</head>
                              </div>
                           </div>
                        </egXML> The first head creates the larger main site title; the second head
                        element (the one with <att>type</att>=<val>subtitle</val>) creates the
                        smaller text at the bottom of the image. But edit with caution: the CSS is
                        created to handle this precise text, so you may have to fiddle with the CSS
                        in site/css/index.css to get your desired results. </p>
                  </div>
                  <div>
                     <head>Editing the <q>About</q> text</head>
                     <p>The About text (the small block of text that begins the home page) is found
                        within the <code>div/@xml:id='index_info'</code>. It currently looks
                        something like this: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <div xml:id="index_info">
                              <head>The wild and wonderful career of a pioneer Asian American
                                 writer</head>
                              <p><!--Content here...-->
                                 <ptr type="readMore" target="doc:about"/>
                              </p>
                           </div>
                        </egXML> The text in the <gi>head</gi> determines the heading content for
                        that block; the text in the paragraph is the paragraph below. The
                           <gi>ptr</gi> is what produces the <q>READ MORE</q> text; more information
                        about READ MORE links below. </p>

                  </div>
                  <div>
                     <head>Editing the <q>Archive Film Strip</q>
                     </head>
                     <p>The Archive strip that runs vertically along the right hand side (in desktop
                        view) is currently encoded as a <gi>list</gi> with <att>corresp</att>
                        attributes like so: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <div xml:id="index_archive">
                              <list>
                                 <item corresp="wdt:EarlyExperiment"/>
                                 <item corresp="wdt:Japan"/>
                                 <item corresp="wdt:NewYork"/>
                                 <item corresp="wdt:Alberta"/>
                                 <item corresp="wdt:Hollywood"/>
                              </list>
                           </div>
                        </egXML> The <att>corresp</att> attribute points to the category listing
                        that should be used in the archive strip block. The actual content for those
                        listings is found in <code>taxonomies.xml</code>. More on the taxonomies
                        below. </p>
                  </div>
                  <div>
                     <head>Adding Featured Items</head>
                     <p>The featured items carousel is encoded as a list in the index page
                        (currently with boilerplate text): <egXML
                           xmlns="http://www.tei-c.org/ns/Examples">
                           <div xml:id="index_featuredItems">
                              <head>Featured Items</head>
                              <list type="featuredItems">
                                 <!--These will be the items that are featured-->
                                 <item corresp="doc:LiChingsBaby1"/>
                                 <item corresp="doc:ChineseJapaneseCookbook1"/>
                                 <item corresp="doc:ButcheringBrains1"/>
                                 <item corresp="doc:Marion5"/>
                                 <item corresp="doc:JohnnysCalf1"/>
                                 <item corresp="doc:JapaneseLoveStory1"/>
                              </list>
                           </div>
                        </egXML> Each <gi>item</gi> uses a <att>corresp</att> attribute to point to
                        the document that should be featured using the <val>doc:</val> prefix scheme
                        (i.e. use <val>doc:LiChingsBaby1</val> to point to the document with
                           <att>xml:id</att> of <val>LiChingsBaby1</val>, which should also be named
                           <code>LiChingsBaby1.xml</code> in the data folder). </p>
                     <p>To populate the content of those featured items (i.e. to provide a blurb for
                        them), you must add a <gi>abstract</gi> to the featured document. This
                        allows us to re-use abstracts as we see fit.</p>
                     <p>Place the <gi>abstract</gi> element after the <gi>catRef</gi> elements in
                        the <gi>profileDesc</gi>, like so: <egXML
                           xmlns="http://www.tei-c.org/ns/Examples">
                           <profileDesc>
                              <textClass>
                                 <catRef scheme="wdt:docType" target="wdt:docPrimarySourcePublished"/>
                                 <catRef scheme="wdt:genre" target="wdt:genreShortStory"/>
                                 <catRef scheme="wdt:exhibit" target="wdt:EarlyExperiment"/>
                              </textClass>
                              <abstract resp="pers:MC1">
                                 <p>
                                    <title level="a">Li Ching’s Baby</title>, although one of the
                                    earliest texts signed <q>Onoto Watanna</q>, is set in a Canadian
                                    Chinatown and features characters and themes typically
                                    associated with the works of Winnifred Eaton’s sister, Edith
                                    Eaton (Sui Sin Far). When his Chinese bride gives birth to a
                                    stillborn, a Chinese businessman and smuggler pays his former
                                    French-Canadian lover to replace it, while his wife is sleeping,
                                    with a baby stolen from her white employer.</p>
                              </abstract>
                           </profileDesc>
                        </egXML> There are a few important things to note here: first, you
                           <emph>must</emph> provide an <att>resp</att> that points to the person
                        who is responsible for authoring the abstract (in this case,
                           <val>pers:MC1</val>). If there is more than one author, space separate
                        the resp pointers: <egXML xmlns="http://www.tei-c.org/ns/Examples">
                           <abstract resp="pers:MC1 pers:JLC1">
                              <!--Content here-->
                           </abstract>
                        </egXML> Second, you must also include <emph>one</emph> paragraph in the
                           <gi>abstract</gi>, which will contain all of the content for the
                           abstract/<q>headnote</q>. This will also be displayed on the object pages
                        as a collapsible box in the metadata info. </p>
                  </div>
               </div>
            </div>
            <div>
               <head>Editing the Taxonomies File</head>
               <p>The taxonomy file (<code>taxonomies.xml</code>) contains all of the data for the
                  taxonomies for the WEA project. These taxonomies include: <list>
                     <item>Genre</item>
                     <item>Document type</item>
                     <item>Exhibit</item>
                  </list>
               </p>
               <div>
                  <head>Editing individual taxonomies</head>
                  <p>Each taxonomy is encoded as a <gi>taxonomy</gi> element with nested
                        <gi>category</gi> elements, like so: <egXML
                        xmlns="http://www.tei-c.org/ns/Examples">
                        <taxonomy xml:id="genre">
                           <bibl>Genre</bibl>
                           <category xml:id="genreShortStory">
                              <catDesc>
                                 <term>Short Stories</term>
                              </catDesc>
                           </category>
                           <category xml:id="genreNF">
                              <catDesc>
                                 <term>Non-fiction</term>
                              </catDesc>
                              <category xml:id="genreNFAuto">
                                 <catDesc>
                                    <term>Non-fiction: Autobiography</term>
                                 </catDesc>
                              </category>
                              <category xml:id="genreNFDedication">
                                 <catDesc>
                                    <term>Non-fiction: Dedication</term>
                                 </catDesc>
                              </category>
                              <category xml:id="genreNFInterview">
                                 <catDesc>
                                    <term>Non-Fiction: Interview</term>
                                 </catDesc>
                              </category>
                              <category xml:id="genreNFIntroduction">
                                 <catDesc>
                                    <term>Non-fiction: Introduction</term>
                                 </catDesc>
                              </category>
                              <category xml:id="genreNFEthnography">
                                 <catDesc>
                                    <term>Non-fiction: Ethnography</term>
                                 </catDesc>
                              </category>
                           </category>
                           <!--And so on-->
                        </taxonomy>
                     </egXML> The title for the taxonomy (as it appears on the corresponding
                     taxonomy pages) is contained with the <gi>catDesc</gi>/<gi>term</gi>. </p>
                  <p>The Exhibit taxonomies are a special case that contain more information about
                     each category within that taxonomy: <egXML
                        xmlns="http://www.tei-c.org/ns/Examples">
                        <category xml:id="Japan" n="2">
                           <catDesc> <term>Playing Japanese <date>1897–1922</date>
                              </term>
                              <note>
                                 <p>In 1897, when she was working as a stenographer either in
                                    Cincinnati or Chicago, Winnifred Eaton assumed the identity of <q>
                                       <name ref="pers:WE1">Kitishima Tackehasche</name>
                                    </q>, a young Yokohama-born Japanese writer who published under
                                    the pseudonym <q>
                                       <name ref="pers:WE1">Onoto Watanna</name>
                                    </q>. Eaton’s earliest Japanese stories, <title level="a">A
                                       Japanese Girl</title> purportedly published in Cincinnati’s
                                       <title level="m">Commercial Tribune</title> and <title
                                       level="a">A Japanese Love Story</title> in <title level="m"
                                       >American Youth Magazine</title>, have not been located, but
                                    most of Eaton’s located Japanese-themed short stories, novels,
                                    poetry, and ethnographic journalism are collected here. From
                                    1897 to 1922, Eaton published 12 Japanese novels, scores of
                                    short stories and ethnographic pieces, poetry, and even <ref
                                       target="doc:ChineseJapaneseCookbook1">a co-authored
                                       cookbook</ref>.</p>
                              </note>
                           </catDesc>
                        </category>
                     </egXML> Here, the <gi>catDesc</gi> element contains an additional
                        <gi>note</gi> element; that <gi>note</gi> contains a <gi>p</gi>, which
                     details information about that category. In the current interface, this
                     information appears in the green <q>info</q> box at the top of the page. </p>
               </div>
            </div>

            <div xml:id="editing_timeline">
               <head>Editing the Timeline Page</head>
               <p>The timeline XML document (about/timeline.xml) is a <gi>listEvent</gi> document
                  with <gi>event</gi> elements. Each <gi>event</gi> element has an <att>when</att>
                  to specify the date and a <gi>p</gi> as a description of the event. <egXML
                     xmlns="http://www.tei-c.org/ns/Examples">
                     <listEvent>
                        <event when="1861">
                           <p>Achuen Amoy is baptized <q>Grace</q> in London and travels to China to
                              work as a missionary.</p>
                        </event> <event when="1863">
                           <p>Edward Eaton marries Achuen Amoy in Shanghai more formally, after
                              being married on board ship.</p>
                        </event> <event when="1864">
                           <p>Winnifred’s brother Edward Charles born in China. Eatons return to
                              England soon afterward, settling in Macclesfield. </p>
                        </event>
                     </listEvent>
                  </egXML>
               </p>

               <p>To add an image to the timeline entry, use an <gi>ab</gi> element with a
                     <gi>type</gi>=<val>graphic</val> and a nested <gi>graphic</gi> element. This
                     <gi>graphic</gi> element should have a <att>url</att> attribute that points to
                  an image file located in the /media/ directory like so: <egXML
                     xmlns="http://www.tei-c.org/ns/Examples">
                     <graphic url="media:myPicture.png"/>
                     <!--In another event element-->
                     <graphic url="media:anotherPicture.jpg"/>
                  </egXML> Make sure to also put in a <gi>desc</gi> in the <gi>graphic</gi> for
                  accessibility. <egXML xmlns="http://www.tei-c.org/ns/Examples">
                     <event when="1839">
                        <ab type="graphic">
                           <graphic url="media:fig1.png">
                              <desc>An image of Winnifred Eaton.</desc>
                           </graphic>
                        </ab>
                        <p>Eaton’s father, Edward Eaton, born in Macclesfield, Cheshire,
                           England.</p>
                     </event>
                     <event when="1846">
                        <ab type="graphic">
                           <graphic url="media:fig2.png">
                              <desc>Winnifred Eaton outside of her home in Calgary.</desc>
                           </graphic>
                        </ab>
                        <p>Eaton’s mother, Achuen Amoy, born in China, perhaps in/near Shanghai. As
                           a young child, she is sold to Chinese acrobat and knife-thrower Tuck Quy
                           (Teh-Kwei) and tours China, the United States, France, England, Scotland,
                           and Ireland with the <q>Chinese Magicians</q> (also known as <q>Chinese
                              Jugglers</q>), beginning in 1851.</p>
                     </event>
                  </egXML>
               </p>
            </div>

            <div xml:id="encoding_citing">
               <head>How to Cite Things</head>
               <p>To cite an article or essay (by WE or by others), use the <gi>ref</gi> element
                  with a <att>type</att>/<val>bibl</val> and the <att>target</att> pointing to the
                  bibl <att>xml:id</att> using the <val>cite:</val> prefix. For instance: <egXML
                     xmlns="http://www.tei-c.org/ns/Examples">
                     <p>See <ref type="bibl" target="cite:BIRC1">Birchall</ref> for more
                        information.</p>
                     <p>
                        <title level="m">Li Ching's Baby</title> begins by stating that the couple
                        were <q>married by proxy</q> (<ref type="bibl" target="cite:bibl71"
                           >401</ref>).</p>
                  </egXML> Notice that we have two different <att>xml:id</att> mechanisms: for works
                  by Winnifred Eaton, we use an enumerated system and for secondary, critical work
                  we use an alphanumeric system. In both cases, we use the <val>cite:</val> prefix
                  with the <emph>full <att>xml:id</att> value</emph> to establish the link. </p>
            </div>

         </div>

         <div xml:id="technical">
            <head>Instructions for Developers/Programmers</head>
            <div xml:id="build">
               <head>Site build process</head>
               <p>The WEA follows the Endings principles for digital humanities sustainability; all
                  of the pages are <q>static</q>, and the site itself has no external or server-side
                  dependencies.</p>
               <p>To build the site, you must have installed: <list>
                     <item>ant</item>
                     <item>ImageMagick</item>
                  </list> Note that ImageMagick is dependent on GhostScript (GS).</p>
               <p>Installation of the above is simplest on Mac with Homebrew: <list>
                     <item>Install <ref target="https://brew.sh/">homebrew</ref>
                     </item>
                     <item>Then, install ant, ant-contrib (we currently don't use it, but may in the
                        future), and imagemagick: <code rend="block"> brew install ant </code>
                        <code rend="block"> brew install imagemagick </code>
                        <code rend="block"> brew install ant-contrib </code>
                     </item>
                  </list> If the above are installed properly, then you can run the build at the
                  command line: <code rend="block"> ant -lib lib </code>
               </p>

               <p>The site build happens in a number of steps: <list>
                     <item>All of the source files are validated against the RelaxNG schema and the
                        extracted schematron</item>
                     <item>If all files are valid, then the site build (located in
                           <code>/code/buildSite.xml</code>) is initiated. The crucial steps are as
                        follows: <list>
                           <item>Files </item>
                           <item>All of the source XML is flattened into a single directory and
                              massaged slightly to create the <q>original</q> XML</item>
                           <item>The standalone XML is created from the original XML; the standalone
                              XML includes all of the <q>standoff</q> materials, like people,
                              bibliographic items, and taxonomies referenced in the document. The
                              main point of each standalone file is to include every data point
                              necessary for the site to be taken out of the context of the project
                              and used elsewhere.</item>
                           <item>The XHTML5 pages are created from the standalone XML and then
                              validated against the VNU validator</item>
                        </list>
                     </item>
                     <item>From the site products, we create a search engine, which runs purely
                        using Javascript within the compiled HTML. Each file is tokenized, and each
                        distinct token is stemmed using the Porter Stemmer algorithm. Each distinct
                        stem is created into individual JSON files, which can then be read by the
                        Javascript on the live site. (Note that the search engine is currently
                        experimental and is largely inspired by Martin Holmes' implementation for
                        The John Keats Project and The Robert Graves Diary Project.)</item>
                  </list>
               </p>
               <div xml:id="build_currentImplementation">
                  <head>Current Implementation</head>
                  <p>Currently, the site build process is associated with the Continuous Integration
                     service Travis, which triggers the site build with every commit to the the
                     wea_data repository. Travis runs all of the above steps, and then
                        <term>deploys</term> the products to another repository owned by the
                     Winnifred Eaton Archive, currently called <q>wea</q>. This repository is
                     associated with a Github pages scenario, which allows us to view all changes to
                     the site within minutes of every commit.</p>
                  <p>Once we are happy with the products on the <q>wea</q> site (also called the
                        <q>beta</q> site), those products can then be deployed on another server
                     (currently we use Github pages in another repository, but this will likely
                     change in the future). To be sure, Travis and Github are <emph>not</emph>
                     necessary for the site build, but purely conveniences for the time being and as
                     an experiment to test the feasibility of creating an Endings compliant site
                     with no need for external servers (and thus, theoretically, for free).
                     Currently, the experiment is proving successful.</p>
               </div>
            </div>
            <div xml:id="buildingSchema">
               <head>Building the Schema</head>
               <p>All constraints and documentation are contained within the ODD file, including the
                  RelaxNG schema, the schematron file, and the compiled schematron XSLT.</p>
               <p>To regenerate the schema and the documentation follow these directions</p>
               <p>
                  <emph>In oXygen</emph>: Simply open the ODD file in the oXygen project file and
                  press the red <q>play</q> button.</p>
               <p>
                  <emph>Command line</emph>: in the root project directory (<code>wea_data</code>),
                  run: <code rend="block">ant -lib lib -f code/buildSchemas.xml</code> Note that you
                  must have ant installed. </p>
            </div>
            <div xml:id="technical_basicCodeStructure">
               <head>Basic Code Structure</head>
               <p>All code is contained with the <code>code/</code> directory; of most importance is
                  the <code>/xsl/</code> directory, which contains all of the XSLT stylesheets
                  necessary for creating the static site.</p>
               <p>Each XSLT <q>master</q> file includes a number of <q>module</q> files;
                     <q>modules</q> should never contain other <q>modules</q>. Of course, there's
                  one exception: the XHTML master file loads in a module named
                     <q>xhtml_modules_module.xsl</q>, which contains all of the modules for creating
                  the XHTML. The reason that there is a <q>modules module</q> is so that this
                  documentation can be created using the standard WEA stylesheets so that it can be
                  easily integrated into the regular site build process.</p>
               <p>Each module is documented using the <q>xd:doc</q> elements, which are oXygen
                  specific elements for documenting XSL stylesheets.</p>
            </div>
            <div xml:id="technical_redirects">
               <head>Retiring, Deleting, and Redirecting Documents</head>
               <p>In cases where a document that had previously been released has been renamed,
                  deleted, or merged into another document, we must implement a redirect to make
                  sure any citations, etc, do not break. To do that, use the redirects.xml file (at
                  the root of the repository) and add a new link element that points from the old id
                  to the new id.</p>
            </div>
         </div>


         <div xml:id="diagnostics">
            <head>Diagnostics</head>
            <p>The following are the diagnostics for the Winnifred Eaton Archive project. The
               diagnostics provide a report of potential encoding errors, et cetera.</p>
            <divGen xml:id="diagnostics_content"/>
         </div>

         <div xml:id="versions">
            <head>Versions</head>
            <p>The Winnifred Eaton Archive is published in distinct <q>versions</q>. Each version or
               release can be found on the Winnifred Eaton Archive's <ref
                  target="https://github.com/winnifredeatonarchive/wea_data">GitHub
               repository</ref>. The following documents are automatically generated statistics for
               each version.</p>
            <divGen xml:id="versions_content"/>
         </div>





      </body>
      <back xml:id="appendix">
         <div xml:id="schema">
            <head>Schema Specification</head>
            <schemaSpec ident="wea" start="TEI">
               <moduleRef key="analysis" include="pc"/>

               <moduleRef key="core"
                  include="abbr address addrLine author bibl biblScope choice cit corr date desc divGen editor emph expan foreign gap graphic head hi item l lb label lg list listBibl milestone name note num p pb ptr pubPlace publisher q quote ref reg relatedItem resp respStmt rs sic sp speaker term title unclear"/>
               <moduleRef key="header"
                  include="abstract authority availability biblFull catRef catDesc category change classDecl correction creation distributor edition editorialDecl encodingDesc extent fileDesc hyphenation idno interpretation langUsage language licence listChange listPrefixDef notesStmt normalization prefixDef profileDesc projectDesc publicationStmt punctuation quotation rendition revisionDesc seriesStmt sourceDesc taxonomy teiHeader textClass titleStmt"/>

               <moduleRef key="figures" include="cell figDesc figure table row"/>

               <moduleRef key="linking" include="ab seg anchor link linkGrp"/>

               <moduleRef key="msdescription"
                  include="collection institution msIdentifier repository"/>


               <moduleRef key="namesdates"
                  include="birth death event forename listEvent listOrg listPerson listPlace listRelation location nationality occupation org orgName persName person place placeName surname"/>
               <moduleRef key="tagdocs" include="att code gi val ident egXML"/>
               <!--Include all TEI modules-->
               <moduleRef key="tei"/>

               <moduleRef key="textstructure"
                  include="TEI back body byline closer dateline div docAuthor docDate docImprint docTitle epigraph floatingText front opener text titlePage titlePart trailer salute signed"/>

               <moduleRef key="transcr" include="fw supplied"/>

               <!--MODULE: HEADER-->

               <elementSpec ident="teiHeader" module="header" mode="change">

                  <!--Make all the bits we want of the teiHeader mandatory-->
                  <content>
                     <elementRef key="fileDesc"/>
                     <elementRef key="profileDesc"/>
                     <!--Make encodingDesc optional-->
                     <elementRef key="encodingDesc" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="revisionDesc"/>
                  </content>
               </elementSpec>

               <elementSpec ident="revisionDesc" module="header" mode="change">


                  <constraintSpec scheme="schematron" ident="revisionDesc.changeMustHaveStatus">
                     <desc>The first change element with a status must match the status of the
                        revisionDesc.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:revisionDesc[@status]">
                              <sch:let name="thisStatus" value="@status"/>
                              <sch:let name="firstChange" value="tei:change[@status][1]"/>
                              <sch:assert test="$firstChange/@status = $thisStatus"> ERROR: The
                                 status attribute must match the @status of the latest change
                                 element. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec scheme="schematron" ident="revisionDesc.onlyEmptyWhenEmpty">
                     <desc>Status cannot be set to anything but empty if there's nothing in the
                        document.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:revisionDesc[not(@status='empty')]">
                              <sch:assert
                                 test="not(exists(//tei:text/descendant::tei:gap[@reason='noTranscriptionAvailable']))"
                                 > ERROR: Only "empty" is allowed as a status for documents without
                                 transcriptions. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>


                  <attList>
                     <!--Make status mandatory-->
                     <attDef ident="status" mode="change" usage="req"/>
                  </attList>
               </elementSpec>


               <!--Make profileDesc/textClass mandatory-->
               <elementSpec ident="profileDesc" module="header" mode="change">
                  <content>
                     <elementRef key="textClass"/>
                     <elementRef key="abstract" minOccurs="0" maxOccurs="1"/>
                  </content>
               </elementSpec>

               <elementSpec ident="abstract" module="header" mode="change">
                  <content>
                     <!--Constrain the abstract to a single paragraph-->
                     <elementRef key="p"/>
                  </content>
                  <attList>
                     <attDef ident="resp" usage="req" mode="replace">
                        <!--Taken from the TEI-->
                        <gloss versionDate="2009-11-02" xml:lang="en">responsible party</gloss>
                        <gloss versionDate="2007-12-20" xml:lang="ko">책임 당사자</gloss>
                        <gloss versionDate="2008-04-06" xml:lang="es">parte responsable</gloss>
                        <gloss versionDate="2008-03-30" xml:lang="fr">responsable</gloss>
                        <gloss versionDate="2007-11-06" xml:lang="it">responsabile</gloss>
                        <desc versionDate="2009-11-02" xml:lang="en">indicates the agency
                           responsible for the intervention or interpretation, for example an editor
                           or transcriber.</desc>
                        <desc versionDate="2007-12-20" xml:lang="ko">편집자 또는 전사자와 같이 또는 해석에 대한 책임이 있는
                           대리인을 나타낸다.</desc>
                        <desc versionDate="2007-05-02" xml:lang="zh-TW"
                           >指出負責該更動或詮釋的代理者，例如編輯或轉錄者。</desc>
                        <desc versionDate="2008-04-05" xml:lang="ja"
                           >当該解釈や調整の責任者を示す．例えば，編集者，翻訳者など．</desc>
                        <desc versionDate="2007-06-12" xml:lang="fr">indique l'agent responsable de
                           l'intervention ou de l'interprétation, par exemple un éditeur ou un
                           transcripteur.</desc>
                        <desc versionDate="2007-05-04" xml:lang="es">indica el agente responsable de
                           la intervención o la interpretación, p.ej. un editor o un
                           transcriptor.</desc>
                        <desc versionDate="2007-01-21" xml:lang="it">indica il responsabile
                           dell'intervento o interpretazione, per esempio un curatore o
                           trascrittore</desc>
                        <datatype maxOccurs="unbounded">
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                        <remarks versionDate="2014-12-10" xml:lang="en">
                           <p>To reduce the ambiguity of a <att>resp</att> pointing directly to a
                              person or organization, we recommend that <att>resp</att> be used to
                              point not to an agent (<gi>person</gi> or <gi>org</gi>) but to a
                                 <gi>respStmt</gi>, <gi>author</gi>, <gi>editor</gi> or similar
                              element which clarifies the exact role played by the agent. Pointing
                              to multiple <gi>respStmt</gi>s allows the encoder to specify clearly
                              each of the roles played in part of a TEI file (creating,
                              transcribing, encoding, editing, proofing etc.).</p>
                        </remarks>
                     </attDef>
                  </attList>
               </elementSpec>

               <elementSpec ident="head" module="core" mode="change">
                  <attList>
                     <attDef ident="type" mode="replace" usage="opt">
                        <valList type="closed">
                           <valItem ident="subtitle">
                              <gloss>subtitle</gloss>
                              <desc>a subtitle or header.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>

               <elementSpec ident="lb" module="core" mode="change">
                  <constraintSpec scheme="schematron" ident="textClass.oneofEach">
                     <desc>Don't allow lbs ANYWHERE except in floating texts or front matter.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:lb">
                              <sch:assert test="ancestor::tei:floatingText or ancestor::tei:front">
                                 ERROR: Line beginning elements should ONLY be used in very special
                                 cases where lineation matters; currently that means only within
                                 floating texts. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>

               </elementSpec>

               <!--And make at least one catRef mandatory-->
               <elementSpec ident="textClass" module="header" mode="change">
                  <content>
                     <elementRef key="catRef" minOccurs="1" maxOccurs="unbounded"/>
                  </content>
                  <constraintSpec scheme="schematron" ident="textClass.oneofEach">
                     <desc>An XSLT restraint for one of each catRef</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule
                              context="tei:textClass[tei:catRef[@scheme='wdt:docType'][contains(@target,'Primary')]][ancestor::tei:TEI/descendant::tei:revisionDesc[@status=('readyForProof','published')]]">
                              <sch:assert
                                 test="tei:catRef[@scheme='wdt:genre'] and tei:catRef[@scheme='wdt:exhibit']"
                                 > ERROR: All primary soruce documents that are ready for proofing
                                 or published MUST have a genre and exhibit. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>

               </elementSpec>

               <elementSpec ident="biblScope" module="core" mode="change">
                  <attList>
                     <attDef ident="unit" mode="replace" usage="req">
                        <valList type="closed">
                           <valItem ident="volume" mode="add">
                              <desc>volume</desc>
                              <gloss>the element contains a volume number</gloss>
                           </valItem>
                           <valItem ident="issue" mode="add">
                              <desc>issue</desc>
                              <gloss>the element contains a issue number</gloss>
                           </valItem>
                           <valItem ident="page" mode="add">
                              <desc>volume</desc>
                              <gloss>the element contains a page number or page range</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>

               <elementSpec ident="extent" module="header" mode="change">
                  <constraintSpec scheme="schematron" ident="extent.legacy">
                     <desc>We allow extent ONLY for legacy purposes.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:extent">
                              <sch:assert test="ancestor::tei:biblFull[ancestor::tei:sourceDesc]">
                                 ERROR: Do not use the extent element; it is to be used in the
                                 context of a biblFull in a source description. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>



               <elementSpec ident="catRef" module="header" mode="change">

                  <constraintSpec scheme="schematron" ident="catRef.occurence">
                     <desc>An XsLT generated co-occurence constraint</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:catRef[@scheme='wdt:docType']">
                              <sch:assert
                                 test="matches(@target,'^((wdt:docPrimarySource)|(wdt:docPrimarySourceMS)|(wdt:docPrimarySourcePublished)|(wdt:docBornDigital)|(wdt:docBornDigitalListing)|(wdt:docBornDigitalDocumentation))$')"
                                 > ERROR: Value <sch:value-of select="@target"/> not allowed for
                                 category reference <sch:value-of select="@scheme"/>
                              </sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:catRef[@scheme='wdt:genre']">
                              <sch:assert
                                 test="matches(@target,'^((wdt:genreShortStory)|(wdt:genreNF)|(wdt:genreNFAuto)|(wdt:genreNFDedication)|(wdt:genreNFLetter)|(wdt:genreNFInterview)|(wdt:genreNFIntroduction)|(wdt:genreNFEthnography)|(wdt:genreFilm)|(wdt:genreFilmScenario)|(wdt:genreFilmTreatment)|(wdt:genreFilmScreenplay)|(wdt:genrePoem)|(wdt:genreNovel)|(wdt:genreNovelSerial))$')"
                                 > ERROR: Value <sch:value-of select="@target"/> not allowed for
                                 category reference <sch:value-of select="@scheme"/>
                              </sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:catRef[@scheme='wdt:exhibit']">
                              <sch:assert
                                 test="matches(@target,'^((wdt:Japan)|(wdt:Alberta)|(wdt:Hollywood)|(wdt:EarlyExperiment)|(wdt:NewYork))$')"
                                 > ERROR: Value <sch:value-of select="@target"/> not allowed for
                                 category reference <sch:value-of select="@scheme"/>
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>

                  </constraintSpec>
                  <attList>
                     <attDef ident="cert" mode="delete"/>
                     <attDef ident="change" mode="delete"/>
                     <attDef ident="facs" mode="delete"/>
                     <attDef ident="rend" mode="delete"/>
                     <attDef ident="source" mode="delete"/>
                     <attDef ident="xml:id" mode="delete"/>
                     <attDef ident="xml:lang" mode="delete"/>
                     <attDef ident="corresp" mode="delete"/>
                     <attDef ident="n" mode="delete"/>
                     <attDef ident="rendition" mode="delete"/>
                     <attDef ident="resp" mode="delete"/>
                     <attDef ident="style" mode="delete"/>
                     <!--Auto generated values-->
                     <attDef ident="scheme" mode="change" usage="req">
                        <valList mode="add" type="closed">
                           <valItem mode="add" ident="wdt:docType">
                              <desc>Document Type</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genre">
                              <desc>Genre</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:exhibit">
                              <desc>Exhibit</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="target" mode="change" usage="req">
                        <valList mode="add" type="closed">
                           <valItem mode="add" ident="wdt:docPrimarySource">
                              <desc>Primary Source</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:docPrimarySourceMS">
                              <desc>Primary Source: Manuscripts</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:docPrimarySourcePublished">
                              <desc>Primary Source: Published</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:docBornDigital">
                              <desc>Born Digital document</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:docBornDigitalListing">
                              <desc>Listing Pages</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:docBornDigitalDocumentation">
                              <desc>Documentation</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreShortStory">
                              <desc>Short Story</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNF">
                              <desc>Non-fiction</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFAuto">
                              <desc>Non-fiction: Autobiography</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFDedication">
                              <desc>Non-fiction: Dedication</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFLetter">
                              <desc>Non-fiction: Letter</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFInterview">
                              <desc>Non-Fiction: Interview</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFIntroduction">
                              <desc>Non-fiction: Introduction</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNFEthnography">
                              <desc>Non-fiction: Ethnography</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreFilm">
                              <desc>Film</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreFilmScenario">
                              <desc>Film: Scenario</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreFilmTreatment">
                              <desc>Film: Treatment</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreFilmScreenplay">
                              <desc>Film: Screenplay</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genrePoem">
                              <desc>Poem</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNovel">
                              <desc>Novel</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:genreNovelSerial">
                              <desc>Novel: Serial</desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:Japan">
                              <desc>Playing Japanese </desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:Alberta">
                              <desc>Alberta </desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:Hollywood">
                              <desc>In Hollywood </desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:EarlyExperiment">
                              <desc>Early Experiments </desc>
                           </valItem>
                           <valItem mode="add" ident="wdt:NewYork">
                              <desc>New York Years </desc>
                           </valItem>
                        </valList>
                     </attDef>

                  </attList>

               </elementSpec>


               <elementSpec mode="change" module="header" ident="sourceDesc">
                  <content>
                     <alternate>
                        <elementRef key="p"/>
                        <alternate minOccurs="1" maxOccurs="unbounded">
                           <elementRef key="bibl"/>
                           <elementRef key="biblFull"/>
                        </alternate>
                     </alternate>
                  </content>
                  <constraintSpec ident="useBiblInPS" scheme="schematron">
                     <desc>All primary sources must use a <gi>bibl</gi> element in the
                           <gi>sourceDesc</gi>
                     </desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:sourceDesc[not(tei:bibl)]">
                              <sch:assert
                                 test="some $d in $docTypes satisfies matches($d, 'BornDigital')">
                                 ERROR: All not born digital documents must use a &lt;bibl&gt;
                                 element in their source descriptions. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>

               <!--LINKING-->


               <elementSpec ident="ptr" module="core" mode="change">
                  <constraintSpec scheme="schematron" ident="ptr.readMore">
                     <desc>We allow extent ONLY for legacy purposes.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:ptr">
                              <sch:assert test="ancestor::tei:TEI/@xml:id='index'"> ERROR: Only use
                                 the ptr element in the index page, and it must have
                                 type='readMore'. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec scheme="schematron" ident="ptr.readMore">
                     <desc>We allow extent ONLY for legacy purposes.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:ptr">
                              <sch:assert test="matches(@target,'^doc:')"> ERROR: All ptr elements
                                 must have a @target attribute that points to a document using the
                                 doc: prefix. (ie. &lt;ptr target="doc:LiChingsBaby1"/&gt;)
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="replace" usage="req">
                        <valList type="closed">
                           <valItem ident="readMore" mode="add">
                              <desc>Read More</desc>
                              <gloss>A "read more" link used on the Index page</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="target" mode="change" usage="req"/>
                  </attList>

               </elementSpec>


               <!--NAMESDATES-->

               <!--Modify persName so that we need at least one of reg, forename, and surname-->
               <elementSpec ident="persName" module="namesdates" mode="change">
                  <content>
                     <elementRef key="reg" minOccurs="1" maxOccurs="1"/>
                     <elementRef key="forename" minOccurs="1" maxOccurs="unbounded"/>
                     <elementRef key="surname" minOccurs="1" maxOccurs="unbounded"/>
                  </content>
               </elementSpec>

               <elementSpec ident="person" module="namesdates" mode="change">

                  <constraintSpec scheme="schematron" ident="person.noContentOnlyCorrespInFigure">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:person[ancestor::tei:figure]">
                              <sch:assert
                                 test="@corresp and normalize-space(string-join(descendant::text())) =''"
                                 > ERROR: People referenced in figures should only contain an
                                 @corresp to the person in question and no content. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec scheme="schematron" ident="person.dontUseRoleOtherThanInFigure">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:person[@role]">
                              <sch:assert test="ancestor::tei:figure"> ERROR: The @role attribute is
                                 only allowed on person in the context of a figure. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec scheme="schematron" ident="person.dontUseRoleOtherThanInFigure">
                     <constraint>
                        <sch:pattern>
                           <sch:rule
                              context="tei:person[ancestor::tei:listPerson and ancestor::tei:figure]">
                              <sch:assert test="@role"> ERROR: All people in a listPerson in a
                                 figure should have a @role attribute. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="role" mode="change">
                        <valList type="closed">
                           <valItem mode="add" ident="subject">
                              <gloss>Subject</gloss>
                              <desc>A subject of a photograph; most often this will be Winnifred
                                 Eaton.</desc>
                           </valItem>
                           <valItem mode="add" ident="subject">
                              <gloss>Photographer</gloss>
                              <desc>The photographer, if known.</desc>
                           </valItem>
                           <valItem mode="add" ident="subject">
                              <gloss>Illustrator</gloss>
                              <desc>The illustrator of the illustration.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>

               <!--CORE-->

               <!--Make respStmt content very strict-->
               <elementSpec ident="respStmt" module="core" mode="change">
                  <content>
                     <elementRef key="resp"/>
                     <elementRef key="name"/>
                  </content>
               </elementSpec>

               <elementSpec ident="author" module="core" mode="change">
                  <attList>
                     <attDef ident="type" mode="replace">
                        <valList type="closed" mode="add">
                           <valItem mode="add" ident="illustrator">
                              <desc>illustrator</desc>
                              <gloss>The illustrator of this document</gloss>
                           </valItem>
                           <valItem ident="photographer">
                              <desc>photographer</desc>
                              <gloss>The photographer within this document</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="role" usage="opt" mode="add">
                        <desc versionDate="2009-10-12" xml:lang="en">may be used to specify further
                           information about the entity referenced by this name in the form of a set
                           of whitespace-separated values, for example the occupation of a person,
                           or the status of a place.</desc>
                        <datatype maxOccurs="unbounded">
                           <dataRef key="teidata.enumerated"/>
                        </datatype>
                     </attDef>
                  </attList>
               </elementSpec>

               <elementSpec ident="catDesc" module="core" mode="change">
                  <content>
                     <alternate minOccurs="0" maxOccurs="unbounded">
                        <textNode/>
                        <classRef key="model.limitedPhrase"/>
                        <classRef key="model.catDescPart"/>
                        <!--CUSTOMIZATION: BREAKS TEI-->
                        <elementRef key="note"/>
                     </alternate>
                  </content>
               </elementSpec>

               <elementSpec ident="choice" module="core" mode="change">
                  <content>
                     <alternate>
                        <sequence>
                           <elementRef key="sic"/>
                           <elementRef key="corr"/>
                        </sequence>
                        <sequence>
                           <elementRef key="abbr"/>
                           <elementRef key="expan"/>
                        </sequence>
                     </alternate>

                  </content>
               </elementSpec>

               <elementSpec ident="note" module="core" mode="change">
                  <constraintSpec scheme="schematron" ident="note.authorialInQOnly">
                     <desc>Use authorial notes only within <gi>q</gi> elements</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[@type='authorial']">
                              <sch:assert test="ancestor::tei:q"> ERROR: Authorial notes should only
                                 be used within the q element. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec scheme="schematron" ident="note.useAuthorialOrEditorialInQ">
                     <desc>All notes within the <gi>q</gi> element should have a type.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[ancestor::tei:q]">
                              <sch:assert test="@type"> ERROR: Notes within the q element should
                                 have a type of either authorial or editorial. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>

                  <constraintSpec scheme="schematron"
                     ident="note.editorialOnesShouldFollowTrailingPunct">
                     <desc>Editorial notes should following trailing punctuation.</desc>

                     <constraint>
                        <sch:rule context="tei:note[@type='editorial']">
                           <sch:let name="folText" value="following-sibling::text()[1]"/>
                           <sch:assert test="not(matches($folText, '^[\.,\?:;]'))"> ERROR: Editorial
                              notes should be placed after the trailing punctuation. </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>

                  <constraintSpec scheme="schematron" ident="persPointersShouldBeCaps">
                     <desc>All notes within the <gi>q</gi> element should have a type.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:*[some $r in @* satisfies matches($r,'pers:')]">
                              <sch:let name="atts"
                                 value="for $a in @* return if (contains($a,'pers:')) then tokenize($a,'\s+') else ()"/>
                              <sch:let name="vals"
                                 value="for $a in $atts return if (starts-with($a,'pers:')) then $a else ()"/>
                              <sch:let name="errors"
                                 value="for $v in $vals return if (matches($v,'^pers:[A-Z]+\d+$')) then () else $v"/>
                              <sch:assert test="empty($errors)"> ERROR: All pers pointers (i.e. the
                                 string after 'pers:') must be a sequence of capital letters and a
                                 digit (bad val: <sch:value-of select="string-join($errors,' ')"/>)
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec scheme="schematron" ident="note.editorialShouldHaveResp">
                     <desc>Editorial notes should always have an <att>resp</att>.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[@type='editorial']">
                              <sch:assert test="@resp"> ERROR: Editorial notes should have a @resp
                                 attribute pointing to the person who authored this note.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec scheme="schematron" ident="note.bioOnlyInPerson">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:person/tei:note | tei:org/tei:note">
                              <sch:assert test="tei:p"> ERROR: All person and org notes must contain
                                 at least one paragraph. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec scheme="schematron" ident="note.bioOnlyInPerson">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:person/tei:note | tei:org/tei:note">
                              <sch:let name="text" value="normalize-space(string-join(text(),''))"/>
                              <sch:assert test="$text=''"> ERROR: All textual content for person/org
                                 notes should be contained within a paragraph. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="replace">
                        <valList mode="add" type="closed">
                           <valItem ident="editorial" mode="add">
                              <desc>editorial</desc>
                              <gloss>an editorial note (i.e. supplied by an editor)</gloss>
                           </valItem>
                           <valItem ident="authorial" mode="add">
                              <desc>authorial</desc>
                              <gloss>an authorial note; currently only used with quotations where
                                 the author interrupts the dominant narrative voice by interjecting
                                 explanatory commentary.</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>

               </elementSpec>

               <elementSpec ident="q" module="core" mode="change">
                  <constraintSpec ident="q.dontStartEndSpaces" scheme="schematron">
                     <desc>
                        <gi>q</gi> elements shouldn't start or end with spaces.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:q[not(ancestor::tei:TEI/@xml:id='wea')]">
                              <sch:let name="text" value="string-join(descendant::text(),'')"/>
                              <sch:assert
                                 test="if (normalize-space(string-join(child::text())) ='') then true() else not(matches($text,'^\s+|\s+$'))"
                                 > ERROR: q elements should not begin or end with spaces.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>

               <elementSpec ident="foreign" module="core" mode="change">
                  <constraintSpec ident="foreign.dontStartEndSpaces" scheme="schematron">
                     <desc>
                        <gi>foreign</gi> elements shouldn't start or end with spaces.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:foreign">
                              <sch:let name="text" value="string-join(text(),'')"/>
                              <sch:assert test="not(matches($text,'^\s+|\s+$'))"> ERROR: foreign
                                 elements should not begin or end with spaces. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>

               <elementSpec ident="name" module="core" mode="change">
                  <attList>
                     <attDef ident="key" mode="add" usage="opt">
                        <desc xml:lang="en">provides an externally-defined means of identifying the
                           entity (or entities) being named, using a coded value of some
                           kind.</desc>
                        <datatype>
                           <dataRef key="teidata.text"/>
                        </datatype>
                        <exemplum xml:lang="en">
                           <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:lang="en"
                              source="#NONE">
                              <author>
                                 <name key="name 427308" type="organisation">[New Zealand
                                    Parliament, Legislative Council]</name>
                              </author>
                           </egXML>
                        </exemplum>
                        <exemplum xml:lang="en">
                           <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:lang="fr"
                              source="#NONE">
                              <author>
                                 <name key="Hugo, Victor (1802-1885)"
                                    ref="http://www.idref.fr/026927608">Victor Hugo</name>
                              </author>
                           </egXML>
                        </exemplum>

                        <remarks versionDate="2013-06-20" xml:lang="en">
                           <p>For the Winnifred Eaton Project, we use the <att>key</att> attribute
                              to signify the pseudonym for the pseudonym table.</p>
                           <p>The value may be a unique identifier from a database, or any other
                              externally-defined string identifying the referent. </p>
                           <p>No particular syntax is proposed for the values of the <att>key</att>
                              attribute, since its form will depend entirely on practice within a
                              given project. For the same reason, this attribute is not recommended
                              in data interchange, since there is no way of ensuring that the values
                              used by one project are distinct from those used by another. In such a
                              situation, a preferable approach for magic tokens which follows
                              standard practice on the Web is to use a <att>ref</att> attribute
                              whose value is a tag URI as defined in <ref target="#RFC4151">RFC
                                 4151</ref>.</p>
                        </remarks>
                        <remarks versionDate="2009-05-25" xml:lang="fr">
                           <p>La valeur peut être un identifiant unique dans une base de données, ou
                              toute autre chaîne définie de façon externe identifiant le référent.
                           </p>
                        </remarks>
                        <remarks xml:lang="ja" versionDate="2018-12-31">
                           <p>値はデータベースにおけるユニークな識別子や、外部で定義された指示対象を特定するなんらかの文字列であってよい。<att>key</att>属性の値に関してさだまった構文は提案されていない。なぜならば、それぞれのプロジェクトのやりかたに完全に依存するからである。同様の理由によって、データの相互交換においてこの属性は推奨されない。在るプロジェクトで用いられた値が他のプロジェクトの値と異なることを保証できないからである。そのような場面における魔法石的対処は、<ref
                                 target="#RFC4151"
                              >RFC4151</ref>に定義されるタグURIを値とする<att>ref</att>属性を用いて、標準的なウェブにおける習慣にしたがってmagic
                              tokenを使うことである。</p>
                        </remarks>
                     </attDef>
                     <attDef ident="ref" mode="add">
                        <datatype minOccurs="1" maxOccurs="unbounded">
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </elementSpec>

               <elementSpec ident="rs" module="core" mode="change">
                  <attList>
                     <attDef ident="key" mode="delete"/>
                     <attDef ident="ref" mode="add">
                        <datatype minOccurs="1" maxOccurs="unbounded">
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </elementSpec>


               <elementSpec ident="bibl" module="core" mode="change">
                  <constraintSpec ident="bibl.noJournalTitle" scheme="schematron">
                     <desc>If you have issues and numbers, you should have a journal title.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:bibl[tei:biblScope[@unit=('issue','volume')]]">
                              <sch:assert test="descendant::tei:title[@level='j']" role="warning">
                                 WARNING: You have encoded issues and volumes, but no journal title.
                                 Are you sure this is correct? </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="bibl.secondaryMustHaveDate" scheme="schematron">
                     <desc>If you have issues and numbers, you should have a journal title.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule
                              context="tei:bibl[ancestor::tei:div[@xml:id='bibliography_resources']]">
                              <sch:assert
                                 test="tei:date[@when or @notBefore or @notAfter or @to or @from]">
                                 ERROR: All secondary bibliography entries must encode a
                                 &lt;date&gt; element </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="bibl.sourceDescShouldUseCopyOf" scheme="schematron">
                     <desc>All <att>n</att> attributes on <gi>pb</gi> elements should be
                        numerical.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule
                              context="tei:sourceDesc[not(ancestor::tei:sourceDesc)]/tei:bibl">
                              <sch:assert test="@copyOf and starts-with(@copyOf,'bibl:')"> ERROR:
                                 All bibls should have an @copyOf that points to the bibl id number
                                 of the bibliographic item in question (i.e. copyOf="bibl:77").
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>

               <elementSpec ident="pb" module="core" mode="change">
                  <constraintSpec ident="pb.pageNumbersShouldBeNumerical" scheme="schematron">
                     <desc>All <att>n</att> attributes on <gi>pb</gi> elements should be
                        numerical.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:pb[@n]">
                              <sch:assert
                                 test="matches(@n,'^((\d+[a-z]?)|(frontcover)|(backcover)|([xiv]+))$')"
                                 > ERROR: All @n attributes on page beginnings should start with
                                 numbers (and optionally end a alphanumeric string). </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="text.thereShouldBeAnInitialPb" scheme="schematron">
                     <desc>Any text with <gi>pb</gi> elements should have an initial one.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:text[descendant::tei:pb]">
                              <sch:assert test="child::tei:*[1]/self::tei:pb"> ERROR: Every text
                                 with page beginnings should start with an initial pb element. The
                                 first page number encountered is <sch:value-of
                                    select="descendant::tei:pb[@n][1]/@n"/>. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="pb.unique" scheme="schematron">
                     <desc>Any text with <gi>pb</gi> elements should have an initial one.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:pb">
                              <sch:assert test="empty(preceding::tei:pb[@n = current()/@n])"> ERROR:
                                 All pb/@n should be unique within a document: <sch:value-of
                                    select="current()/@n"/>. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="n" mode="change" usage="req"/>
                  </attList>

               </elementSpec>

               <elementSpec ident="title" module="core" mode="change">
                  <constraintSpec ident="text.onlyJLevelTitlesShouldHaveRef" scheme="schematron">
                     <desc>Only journal titles should have @ref.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:title[@ref]">
                              <sch:assert test="@level='j'"> ERROR: Only "j" level titles should use
                                 the @ref attribute. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>


               <!--MODULE:FIGURES-->

               <elementSpec ident="figure" module="figures" mode="change">
                  <content>
                     <elementRef key="head" minOccurs="0"/>
                     <elementRef key="graphic" minOccurs="0"/>
                     <elementRef key="figDesc" minOccurs="0"/>
                     <elementRef key="bibl" minOccurs="0"/>
                     <elementRef key="listPerson" minOccurs="0"/>
                  </content>
                  <constraintSpec ident="figure.needsSomething" scheme="schematron">
                     <!--This constraint could certainly be done in pure ODD and not
                        schematron-->
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:figure">
                              <sch:assert test="tei:*"> ERROR: All figures should have at least one
                                 element in it. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="figure.inListFigureMustHaveType" scheme="schematron">
                     <desc>Every figure in the figure database should have a type value.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:figure[ancestor::tei:div[@type='listFigure']]">
                              <sch:assert test="@type"> ERROR: Every figure in the figure database
                                 must have an @type value. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="figure.inListFigureMustHaveStructuredData"
                     scheme="schematron">
                     <desc>Every figure in the figure database should have structured data</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule
                              context="tei:figure[ancestor::tei:div[@type='listFigure']][not(@type='generated')]">
                              <sch:assert test="tei:head and tei:figDesc and tei:bibl"> ERROR: Every
                                 figure in the media database must include a head element, a figDesc
                                 element, and a bibl element. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="replace">
                        <valList type="closed" mode="add">
                           <valItem ident="photograph">
                              <gloss>Photograph</gloss>
                              <desc>A photograph of some subject; note that this does NOT include
                                 photographs of facsimiles, et cetera.</desc>
                           </valItem>
                           <valItem ident="advertisement">
                              <gloss>Advertisement</gloss>
                              <desc>Advertisements for books, films, et cetera. This includes
                                 objects like posters.</desc>
                           </valItem>
                           <valItem ident="illustration">
                              <gloss>Illustration</gloss>
                              <desc>An illustration from a text. This includes ornamental letters
                                 and other pictorial content within a printed artifact.</desc>
                           </valItem>
                           <valItem ident="paratext">
                              <gloss>Paratextual Materials</gloss>
                              <desc>Materials that are related to a text, but are not necessarily
                                 part of the central text. This category includes objects like
                                 mastheads, covers, and other print cultural artifacts.</desc>
                           </valItem>
                           <valItem ident="ephemera">
                              <gloss>Ephemera</gloss>
                              <desc>Any other figure that does not fall into a more specific
                                 category.</desc>
                           </valItem>
                           <valItem ident="generated">
                              <gloss>Generated Image</gloss>
                              <desc>DO NOT USE: An image generated from the file structure; this is
                                 an temporary solution.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>

               </elementSpec>

               <elementSpec ident="graphic" module="core" mode="change">
                  <constraintSpec ident="graphic.inListFigShouldHaveMimetype" scheme="schematron">
                     <desc>All graphics in the listFigure should have a mimetype attribute.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:graphic[ancestor::tei:div[@type='listFigure']]">
                              <sch:assert test="@mimeType"> ERROR: All media in the media database
                                 should use the @mimeType attribute to specify the source mimetype.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="graphic.noSpaceInUrl" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:*[@url]">
                              <sch:assert test="not(matches(@url,'\s+'))"> ERROR: Do not put spaces
                                 in image names. If it is an image in the repository, please rename
                                 it to not use spaces. </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>


               <!--MODULE: TEXTSTRUCTURE-->
               <elementSpec ident="div" module="textstructure" mode="change">
                  <constraintSpec ident="div.listFigureShouldContainItselfOrListFigure"
                     scheme="schematron">
                     <desc>Figure list divs should only contain figures or itself.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:div[@type='listFigure']/tei:*">
                              <sch:assert
                                 test="self::tei:div[@type='listFigure'] or self::tei:figure">
                                 ERROR: listFigure divs should only contain figures or itself.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change">
                        <valList mode="add" type="closed">
                           <valItem ident="chapter" mode="add">
                              <desc>chapter</desc>
                              <gloss>A chapter in a longer work</gloss>
                           </valItem>
                           <valItem ident="content" mode="add">
                              <desc>content</desc>
                              <gloss>The main content</gloss>
                           </valItem>
                           <valItem ident="paratext" mode="add">
                              <desc>paratext</desc>
                              <gloss>Paratextual material, likely NOT written by WE</gloss>
                           </valItem>
                           <valItem ident="section" mode="add">
                              <desc>section</desc>
                              <gloss>An arbitrary section</gloss>
                           </valItem>
                           <valItem ident="letter" mode="add">
                              <desc>letter</desc>
                              <gloss>DO NOT USE: Used in converted text and should be removed. Use
                                 the floatingText element instead.</gloss>
                           </valItem>
                           <valItem ident="postscript" mode="add">
                              <desc>Postscript</desc>
                              <gloss>DO NOT USE: Used in converted text and should be removed. Use
                                 the postscript element instead.</gloss>
                           </valItem>
                           <valItem ident="listFigure" mode="add">
                              <desc>List of Figures</desc>
                              <gloss>A born-digital list of images; not to be used in primary source
                                 texts.</gloss>
                           </valItem>
                           <valItem ident="exhibitInfo" mode="add">
                              <desc>Exhibit Information</desc>
                              <gloss>DO NOT USE: used only in generated processes for info boxes on
                                 exhibit pages (Japan, Alberta, etc)</gloss>
                           </valItem>
                           <valItem ident="biblio_list" mode="add">
                              <desc>Bibliographic List container</desc>
                              <gloss>DO NOT USE: used only in generated processes for
                                 bibliographies</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>

               <elementSpec ident="fw" module="transcr" mode="change">
                  <attList>
                     <attDef ident="type" mode="replace" usage="req">
                        <valList mode="add" type="closed">
                           <valItem mode="add" ident="continued">
                              <desc>continued</desc>
                              <gloss>A phrase stating a text is continued or a continuation of
                                 another text</gloss>
                           </valItem>
                           <valItem mode="add" ident="copyright">
                              <desc>copyright</desc>
                              <gloss>A statement of copyright</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="place" mode="change" usage="req">
                        <valList mode="add" type="closed">
                           <valItem mode="add" ident="left">
                              <desc>left</desc>
                              <gloss>Left aligned</gloss>
                           </valItem>
                           <valItem mode="add" ident="right">
                              <desc>right</desc>
                              <gloss>Right aligned</gloss>
                           </valItem>
                           <valItem mode="add" ident="center">
                              <desc>center</desc>
                              <gloss>Centered</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>


               <!--CLASS SPECS-->


               <classSpec ident="att.ranging" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.written" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.cReferencing" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.datable" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="period" mode="delete"/>
                  </attList>
               </classSpec>
               <classSpec ident="att.datcat" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.declarable" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.declaring" module="tei" type="atts" mode="delete"/>
               <!--WE need this for rhyme-->
               <classSpec ident="att.divLike" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.docStatus" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef mode="replace" ident="status">
                        <valList mode="add" type="closed">
                           <valItem ident="empty" mode="add">
                              <desc>empty</desc>
                              <gloss>A document that has not yet been transcribed or encoded. Do not
                                 use "empty" if we cannot find or otherwise we believe the text of
                                 this document is lost.</gloss>
                           </valItem>
                           <valItem ident="inProgress" mode="add">
                              <desc>in progress</desc>
                              <gloss>A document that is currently being encoded and is not yet ready
                                 to be proofed. This may be because the transcription is in
                                 progress, a facsimile needs to be added, or for any other reason
                                 where the document has content but is not yet ready to be approved
                                 by the project director.</gloss>
                           </valItem>
                           <valItem ident="readyForProof" mode="add">
                              <desc>ready for proof</desc>
                              <gloss>A document that is ready to be proofed by the project
                                 director.</gloss>
                           </valItem>
                           <valItem ident="published" mode="add">
                              <desc>published</desc>
                              <gloss>A published document.</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </classSpec>
               <classSpec ident="att.duration.w3c" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.duration.iso" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.editLike" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.global" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="xml:base" mode="delete"/>
                     <attDef ident="xml:space" mode="delete"/>
                  </attList>
               </classSpec>
               <classSpec ident="att.global.facs" module="tei" type="atts" mode="change">
                  <constraintSpec scheme="schematron" ident="facs.mustStartWithFacs">
                     <desc>All <att>facs</att> attributes should start with facs</desc>
                     <constraint>
                        <sch:rule context="tei:*[@facs]">
                           <sch:let name="tokens" value="tokenize(@facs,'\s+')"/>
                           <sch:let name="facsRegex" value="'^facs:.+'"/>
                           <sch:assert
                              test="every $t in $tokens satisfies (matches($t,$facsRegex) and not(matches($t,'\..+$')))"
                              > ERROR: All facsimile pointers should start with facs: and not
                              include the file extension. </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </classSpec>
               <classSpec ident="att.global.rendition" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="rend" mode="delete"/>
                  </attList>
               </classSpec>
               <classSpec ident="att.global.linking" module="linking" type="atts" mode="change">
                  <attList>
                     <attDef ident="synch" mode="delete"/>
                     <attDef ident="sameAs" mode="delete"/>
                     <attDef ident="select" mode="delete"/>
                     <attDef ident="exclude" mode="delete"/>
                  </attList>
               </classSpec>
               <classSpec ident="att.handFeatures" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.internetMedia" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="mimeType" mode="change">
                        <valList type="semi" mode="add">
                           <valItem ident="image/png" mode="add">
                              <gloss>PNG</gloss>
                           </valItem>
                           <valItem ident="application/pdf" mode="add">
                              <gloss>PDF</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </classSpec>
               <classSpec ident="att.interpLike" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.measurement" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.naming" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.notation" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.pointing" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="targetLang" mode="delete"/>
                     <attDef ident="evaluate" mode="delete"/>
                  </attList>
               </classSpec>
               <classSpec ident="att.pointingGroup" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.scoping" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.segLike" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.sortable" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.edition" module="tei" type="atts" mode="delete"/>
               <classSpec ident="att.readFrom" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.spanning" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.repeatable" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.timed" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.transcriptional" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.translatable" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.partials" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.personal" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="full" mode="delete"/>
                     <attDef ident="sort" mode="delete"/>
                  </attList>
               </classSpec>


               <classSpec ident="att.global.analytic" type="atts" module="tei" mode="delete"/>
               <classSpec ident="att.pointing.group" type="atts" module="tei" mode="delete"/>

               <!--CONSTRAINTS-->

               <constraintSpec ident="global" scheme="schematron">
                  <constraint>
                     <sch:pattern>
                        <sch:let name="spaceRegex" value="'(^\s)|(\s$)'"/>
                        <sch:let name="docId" value="root(/)/tei:*/@xml:id"/>
                        <sch:let name="docUri" value="document-uri(/)"/>
                        <sch:let name="docIds" value="//tei:*[@xml:id]/@xml:id"/>
                        <sch:let name="docTypes" value="//tei:catRef/@target"/>
                        <sch:let name="docStatus" value="//tei:revisionDesc/@status"/>
                        <sch:let name="isDocumentation"
                           value="some $r in $docTypes satisfies matches($r,'Documentation')"/>
                        <sch:let name="thisUri" value="document-uri(/)"/>
                        <sch:let name="thisProjectDir"
                           value="if (matches($thisUri,'/data/')) then (substring-before($thisUri,'/data/') || '/data/') else replace($thisUri,'[^/]+$','')"/>
                        <sch:let name="theseDocs"
                           value="uri-collection(concat(substring-after($thisProjectDir,'file:'),'?select=*.xml;skip-errors=true;recurse=yes'))"/>
                        <sch:let name="allDocIds"
                           value="for $doc in $theseDocs return replace($doc,'.+/([^/]+)\.xml', '$1')"/>
                        <sch:let name="peopleIds"
                           value="document($theseDocs[matches(.,'people.xml$')][1])//tei:person/@xml:id/xs:string(.)"/>
                        <sch:let name="orgIds"
                           value="document($theseDocs[matches(.,'organizations.xml')][1])//tei:org/@xml:id/xs:string(.)"/>
                        <sqf:fix id="globals">
                           <sqf:description>
                              <sqf:title>Global Templates</sqf:title>
                           </sqf:description>
                           <!--GLOBAL XSL VARIABLES-->
                           <xsl:variable name="apos">'</xsl:variable>
                           <xsl:variable name="dq">"</xsl:variable>
                           <!--TAG BLOCKS TEMPLATE-->
                           <xsl:template name="tagBlocks">
                              <xsl:param name="verse" select="false()"/>
                              <xsl:variable name="ancestors" select="count(ancestor::tei:*)"/>
                              <xsl:variable name="tabCount" select="$ancestors"/>
                              <xsl:variable name="newLine">
                                 <xsl:text>
</xsl:text>
                              </xsl:variable>
                              <xsl:variable name="tab"
                                 select="string-join(for $n in (2 to $tabCount) return '&#x9;','')"/>
                              <xsl:variable name="paras"
                                 select="for $t in tokenize(.,'\n+') return normalize-space($t)"/>
                              <xsl:for-each select="$paras[not(.='')]">
                                 <xsl:value-of select="$newLine"/>
                                 <xsl:value-of select="$tab"/>
                                 <xsl:element name="{if ($verse) then 'l' else 'p'}">
                                    <xsl:value-of select="."/>
                                 </xsl:element>
                              </xsl:for-each>
                           </xsl:template> <xsl:template name="replaceApos">
                              <xsl:param name="useDq" select="false()"/>
                              <xsl:variable name="thisApos" select="if ($useDq) then $dq else $apos"/>
                              <xsl:variable name="left" select="if ($useDq) then '“' else '‘'"/>
                              <xsl:variable name="right" select="if ($useDq) then '”' else '’'"/>
                              <xsl:analyze-string select="." regex="{concat('(^|\s+)',$thisApos)}">
                                 <xsl:matching-substring>
                                    <xsl:value-of select="regex-group(1)"/>
                                    <xsl:value-of select="$left"/>
                                 </xsl:matching-substring>
                                 <xsl:non-matching-substring>
                                    <xsl:analyze-string select="."
                                       regex="{concat('([a-zA-Z])',$thisApos)}">
                                       <xsl:matching-substring>
                                          <xsl:value-of select="regex-group(1)"/>
                                          <xsl:value-of select="$right"/>
                                       </xsl:matching-substring>
                                       <xsl:non-matching-substring>
                                          <xsl:analyze-string select="."
                                             regex="{concat($thisApos,'(\s+|$)')}">
                                             <xsl:matching-substring>
                                                <xsl:value-of select="$right"/>
                                                <xsl:value-of select="regex-group(1)"/>
                                             </xsl:matching-substring>
                                             <xsl:non-matching-substring>
                                                <xsl:value-of select="."/>
                                             </xsl:non-matching-substring>
                                          </xsl:analyze-string>
                                       </xsl:non-matching-substring>
                                    </xsl:analyze-string>
                                 </xsl:non-matching-substring>
                              </xsl:analyze-string>
                           </xsl:template> <xsl:template name="tagQuote">
                              <xsl:param name="left"/>
                              <xsl:param name="right"/>
                              <xsl:variable name="rex1"
                                 select="concat($left,'([^',$right,']+)([\.,])',$right)"/>
                              <xsl:variable name="rex2"
                                 select="concat($left,'([^',$right,']+)',$right)"/>
                              <xsl:analyze-string select="." regex="{$rex1}">
                                 <xsl:matching-substring>
                                    <xsl:element name="q">
                                       <xsl:value-of select="regex-group(1)"/>
                                    </xsl:element>
                                    <xsl:value-of select="regex-group(2)"/>
                                 </xsl:matching-substring>
                                 <xsl:non-matching-substring>
                                    <xsl:analyze-string select="." regex="{$rex2}">
                                       <xsl:matching-substring>
                                          <xsl:element name="q">
                                             <xsl:value-of select="regex-group(1)"/>
                                          </xsl:element>
                                       </xsl:matching-substring>
                                       <xsl:non-matching-substring>
                                          <xsl:value-of select="."/>
                                       </xsl:non-matching-substring>
                                    </xsl:analyze-string>
                                 </xsl:non-matching-substring>
                              </xsl:analyze-string>
                           </xsl:template>
                        </sqf:fix>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>

               <!--Basic constraints-->
               <constraintSpec scheme="schematron" ident="TEI.docNameSameAsId">
                  <desc>All root elements must have an <att>xml:id</att> that matches the document
                     filename.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="/tei:TEI[not(ancestor::tei:teiCorpus)] | /tei:teiCorpus">
                           <sch:assert
                              test="@xml:id and matches($docUri,concat('[/\\]',$docId,'.\w+$'))">
                              ERROR: Document xml:id (<sch:value-of select="$docId"/>) does not
                              match the document file name (<sch:value-of select="$docUri"/>).
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>

               <constraintSpec scheme="schematron" ident="badPersId">
                  <desc>All person ids must be found in the personography.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule
                           context="tei:name[@ref] | tei:change[@who] | tei:rs[@ref] | tei:*[@resp]">
                           <sch:let name="att"
                              value="if (@ref) then @ref else if (@who) then @who else @resp"/>
                           <sch:let name="errors"
                              value="for $i in tokenize($att,'\s+') return if (matches($i,'^(pers:|https://dcs|#)')) then () else $i"/>
                           <sch:assert test="empty($errors)"> ERROR: All personography pointers must
                              start with the pers: prefix.</sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>

               <constraintSpec scheme="schematron" ident="linkGrpForRedirects">
                  <desc>All link/linkGrp elements must ONLY occur in the redirects file.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:linkGrp | tei:link">
                           <sch:assert test="ancestor::tei:TEI/@xml:id = 'redirects'"> ERROR: Only
                              use <sch:name/> in the redirects file. </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:link">
                           <sch:assert test="@target and count(tokenize(@target,'\s+')) = 2"> ERROR:
                              Link must have an @target attribute with two pointers. </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>



               <!--    <constraintSpec scheme="schematron" ident="badPersId">
                  <desc>All person ids must be found in the personography.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:name[@ref] | tei:change[@who] | tei:rs[@ref]">
                           <sch:let name="att" value="if (@ref) then @ref else @who"/>
                           <sch:let name="ids"
                                    value="for $n in tokenize($att,'\s+') return substring-after($n,'pers:')"/>
                           <sch:let name="errors"
                                    value="for $i in $ids return if ($peopleIds[.=$i]) then () else $i"/>
                          <sch:assert test="empty($errors)"> ERROR: Person id <sch:value-of select="string-join($errors,', ')"/> does not exist in the person document. </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>-->
               <constraintSpec scheme="schematron" ident="badOrgPrefix">
                  <desc>All person ids must be found in the personography.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:publisher[@ref]">
                           <sch:let name="errors"
                              value="for $i in tokenize(@ref,'\s+') return if (matches($i,'^org:')) then () else $i"/>
                           <sch:assert test="empty($errors)"> ERROR: All org pointers must start
                              with the org: prefix.</sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>

               <constraintSpec scheme="schematron" ident="changeWithWho">
                  <desc>All change/@who pointers should be properly formatted.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:change[@who]">
                           <sch:let name="errors"
                              value="tokenize(@who,'\s+')[not(matches(.,'^pers:[A-Z]{2}\d+$'))]"/>
                           <sch:assert test="empty($errors)">ERROR: Bad @who value for this change
                              element: <sch:value-of select="string-join($errors,' ')"/>
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               <!--   
               <constraintSpec scheme="schematron" ident="badOrgId">
                  <desc>All publisher ids must be found in the orgs doc.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:publisher[@ref]">
                           <sch:let name="ids"
                                    value="for $n in tokenize(@ref,'\s+') return substring-after($n,'org:')"/>
                           <sch:let name="errors"
                                    value="for $i in $ids return if ($orgIds[.=$i]) then () else $i"/>
                           <sch:assert test="empty($errors)"> ERROR: Org id <sch:value-of select="string-join($errors,', ')"/> does not exist in the organizations document.</sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>-->


               <constraintSpec scheme="schematron" ident="misMatchedQuote">
                  <constraint>
                     <sch:pattern>
                        <sch:rule
                           context="tei:*[not(ancestor-or-self::tei:code)][text()][not($isDocumentation) or ($isDocumentation and not(ancestor::tei:back))]">
                           <sch:let name="onlyOneQuote"
                              value="some $t in text() satisfies (not(count(tokenize($t,'”')) = count(tokenize($t,'“'))))"/>
                           <sch:assert test="not($onlyOneQuote)"> ERROR: Curly quotes that cannot be
                              QuickFixed. Either add the curly quotation mark or change to the q
                              element. </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>

               <constraintSpec scheme="schematron" ident="poemsShouldHaveLinegroups">
                  <desc>If a document is classified as a poem, then it should have linegroup
                     elements.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule
                           context="tei:TEI[descendant::tei:catRef[contains(@target,'Poem')]][not(descendant::tei:revisionDesc/@status='empty')]">
                           <sch:assert
                              test="descendant::tei:text[descendant::tei:lg or descendant::tei:l or descendant::tei:gap[@reason=('readyForProof','inProgress')]]"
                              > ERROR: This document is classified as a poem, but there are no line
                              groups (&lt;lg&gt;) or lines (&lt;l&gt;). Ensure that you do not use
                              paragraph tags if it is a poem. </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>



               <constraintSpec scheme="schematron" ident="nextPrevShouldntBeTheRoot">
                  <desc>The attributes next/prev on a text element shouldn't match the root
                     id.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:text[@next or @prev]">
                           <sch:let name="errors"
                              value="for $r in (@next,@prev) return if (substring-after($r,'doc:')=$docId) then $r else ()"/>
                           <sch:assert test="empty($errors)"> ERROR: Next and prev should point to a
                              different document (i.e. a different installment), but they contain
                              the value(s) <sch:value-of select="string-join($errors,' ')"/>.
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               <!--          
               <constraintSpec scheme="schematron" ident="documentRefsShouldBeGood">
                  <desc>Checks to make sure any doc: ref is actually in the collection</desc>
                  <constraint>
                     <sch:rule context="tei:*[some $a in @* satisfies (matches($a,'(^|\s+)doc:'))]">
                        <sch:let name="atts" value="@*[matches(.,'^|\s+')]"/>
                        <sch:let name="tokens"
                                 value="for $a in $atts return tokenize($a,'\s+')[matches(.,'^doc:')][not(matches(.,'^doc:(Japan|EarlyExperiment|Hollywood|Alberta|NewYork|[A-Z]{2}\d+)$'))]"/>
                        <sch:let name="errors"
                                 value="for $t in $tokens return if (substring-after($t,'doc:')=$allDocIds) then () else $t"/>
                        <sch:assert test="count($errors) = 0">
                           ERROR: Document reference(s) <sch:value-of select="string-join($errors,', ')"/> not found.
                        </sch:assert>
                     </sch:rule>
                  </constraint>
               </constraintSpec>-->


               <constraintSpec scheme="schematron" ident="noSpaceInRefs">
                  <constraint>
                     <sch:pattern>
                        <sch:rule
                           context="tei:name | tei:ref[not(descendant::tei:graphic)] | tei:title | tei:l | tei:orgName | tei:persName/tei:reg">
                           <sch:let name="text" value="string-join(descendant::text(),'')"/>
                           <sch:assert test="not(matches($text,'^\s+|\s+$'))"> ERROR: <sch:name/>
                              should not begin or end with spaces. </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               <!--The square bracket rule won't work, since there 
                  are a few instances where WE uses square brackets-->

               <!--     
               <constraintSpec scheme="schematron" ident="noSpaceInRefs">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:*[not(*)][text()]">
                           <sch:let name="text" value="string-join(text(),'')"/>
                           <sch:assert test="not(matches($text,'[\[\]]'))">
                              ERROR: Do not use square brackets to denote supplied texts. Use the 
                              supplied element if necessary.
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>-->

               <constraintSpec scheme="schematron" ident="noTrailingPeriod.warning">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:name">
                           <sch:let name="text" value="string-join(descendant::text(),'')"/>
                           <sch:assert
                              test="if (matches($text,'^(\w\.)+$')) then true() else not(matches($text,'\.$'))"
                              role="warning"> WARNING: <sch:name/> usually shouldn't end with
                              periods. </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>

               <constraintSpec scheme="schematron" ident="noTrailingPunct">
                  <constraint>
                     <sch:pattern>
                        <sch:rule
                           context="tei:q[not($isDocumentation) or ($isDocumentation and not(ancestor::tei:back))]">
                           <sch:let name="text" value="string-join(descendant::text(),'')"/>
                           <sch:assert test="not(matches($text,'[\.,]$'))"> ERROR: Trailing
                              punctuation should go outside the <sch:name/> element. </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>



               <!--DOCUMENT STATUSES:
                  
                  * empty
                  * inProgress
                  * readyForProof
                  * published
                  
                  -->




               <!--CONSTRAINTS WITH QUICK FIXES-->

               <constraintSpec scheme="schematron" ident="noStraightQuote">
                  <constraint>
                     <sch:pattern>
                        <sch:rule
                           context="tei:body[not($isDocumentation)] | tei:*[not(self::tei:code)][text()][normalize-space(string-join(text(),'')) ne ''][not($isDocumentation) or ($isDocumentation and not(ancestor::tei:back))]">
                           <sch:let name="thisText"
                              value="if (self::tei:body) then string-join(descendant::text()[not(ancestor::tei:code)],'') else string-join(text()[not(ancestor::tei:code)],'')"/>
                           <sch:let name="cp" value="string-to-codepoints($thisText)"/>
                           <sch:let name="distinctCp" value="distinct-values($cp)"/>
                           <sch:assert test="empty($distinctCp[.=34])"
                              sqf:fix="replaceStraightQuotesHere replaceStraightQuotesEverywhere">
                              ERROR: QUICKFIX: Do not use straight quotation marks. </sch:assert>
                           <sqf:fix id="replaceStraightQuotesHere" use-when="self::tei:body">
                              <sqf:description>
                                 <sqf:title>GLOBAL: Replace straight quotation mark with curly
                                    question marks everywhere.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="//text()">
                                 <xsl:call-template name="replaceApos">
                                    <xsl:with-param name="useDq" select="true()"/>
                                 </xsl:call-template>
                              </sqf:replace>
                           </sqf:fix>
                           <sqf:fix id="replaceStraightQuotesEverywhere"
                              use-when="not(self::tei:body)">
                              <sqf:description>
                                 <sqf:title>LOCAL: Replace straight quotation marks with curly
                                    quotation marks in this <sch:name/> element.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="text()">
                                 <xsl:call-template name="replaceApos">
                                    <xsl:with-param name="useDq" select="true()"/>
                                 </xsl:call-template>
                              </sqf:replace>
                           </sqf:fix>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>

               <constraintSpec scheme="schematron" ident="biblsNeedId">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:bibl[ancestor::tei:div[@xml:id='bibliography_we']]">
                           <sch:assert test="@xml:id" sqf:fix="addNewBiblId">ERROR: QUICKFIX: All WE
                              bibls need an id. Click the red lightbulb to the left to add one. </sch:assert>
                           <sch:assert test="@xml:id and matches(@xml:id,'^bibl\d+$')"
                              sqf:fix="replaceBiblId">ERROR: QUICKFIX: All WE bibls need a bibl id
                              in the format bibl#. Click the red lightbulb to the left to replace
                              the current id.</sch:assert>
                           <sqf:fix id="addNewBiblId">
                              <sqf:description>
                                 <sqf:title>Add a new bibl id</sqf:title>
                              </sqf:description>
                              <sqf:add match="." target="xml:id" node-type="attribute">
                                 <xsl:variable name="bibls"
                                    select="for $bibl in ancestor::tei:div[@xml:id='bibliography_we']/descendant::tei:bibl[matches(@xml:id,'^bibl')]/@xml:id return substring-after($bibl,'bibl')"/>
                                 <xsl:variable name="newNum"
                                    select="max(for $n in $bibls return xs:integer($n)) + 1"/>
                                 <xsl:value-of select="'bibl' || $newNum"/> </sqf:add>
                           </sqf:fix>
                           <sqf:fix id="replaceBiblId">
                              <sqf:description>
                                 <sqf:title>Replace bibl id</sqf:title>
                              </sqf:description> <sqf:replace match="@xml:id" node-type="attribute"
                                 target="xml:id">
                                 <xsl:variable name="rBibls"
                                    select="for $bibl in ancestor::tei:div[@xml:id='bibliography_we']/descendant::tei:bibl[matches(@xml:id,'^bibl')]/@xml:id return substring-after($bibl,'bibl')"/>
                                 <xsl:variable name="rNewNum"
                                    select="max(for $n in $rBibls return xs:integer($n)) + 1"/>
                                 <xsl:value-of select="'bibl'||$rNewNum"/>
                              </sqf:replace>
                           </sqf:fix>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>

               <constraintSpec scheme="schematron" ident="noStraightApos">
                  <constraint>
                     <sch:pattern>
                        <sch:rule
                           context="tei:body[not($isDocumentation)] | tei:*[text()][not(self::tei:code)][normalize-space(string-join(text(),'')) ne ''][not($isDocumentation)][not($isDocumentation) or ($isDocumentation and not(ancestor::tei:back))]">
                           <sch:let name="thisText"
                              value="if (self::tei:body) then string-join(descendant::text()[not(ancestor::tei:code)],'') else string-join(text()[not(ancestor::tei:code)],'')"/>
                           <sch:let name="cp" value="string-to-codepoints($thisText)"/>
                           <sch:let name="distinctCp" value="distinct-values($cp)"/>
                           <sch:assert test="empty($distinctCp[.=39])"
                              sqf:fix="replaceAposHere replaceAposEverywhere"> ERROR: QUICKFIX: Do
                              not use straight apostrophes. </sch:assert>
                           <sqf:fix id="replaceAposHere" use-when="self::tei:body">
                              <sqf:description>
                                 <sqf:title>GLOBAL: Replace straight apostrophe with curly
                                    apostrophe everywhere.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="//text()">
                                 <xsl:call-template name="replaceApos"/>
                              </sqf:replace>
                           </sqf:fix>
                           <sqf:fix id="replaceAposEverywhere" use-when="not(self::tei:body)">
                              <sqf:description>
                                 <sqf:title>LOCAL: Replace straight apostrophe with curly apostrophe
                                    in this <sch:name/> element.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="text()">
                                 <xsl:call-template name="replaceApos"/>
                              </sqf:replace>
                           </sqf:fix>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>

               <constraintSpec scheme="schematron" ident="bodyDivsNeedParas">
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:body | tei:div | tei:lg">
                           <sch:let name="divs"
                              value="if (self::tei:body) then (descendant::tei:div) else ."/>
                           <sch:let name="noElContentDivs" value="$divs[not(descendant::*)]"/>
                           <sch:let name="contentDivs"
                              value="$noElContentDivs[not(normalize-space(string-join(text(),''))='')]"/>
                           <sch:assert test="empty($contentDivs)"
                              sqf:fix="fixDivsHere fixDivsEverywhere"> ERROR: QUICKFIX: Untagged
                              text should likely be tagged. Use the Quickfix to do so. </sch:assert>
                           <sqf:fixes> <sqf:fix id="fixDivsHere" use-when="not(self::tei:body)">
                                 <sqf:description>
                                    <sqf:title>LOCAL: Fix this <sch:name/>
                                    </sqf:title>
                                 </sqf:description>
                                 <sqf:replace match="node()">
                                    <xsl:call-template name="tagBlocks">
                                       <xsl:with-param name="verse"
                                          select="if (parent::*/self::tei:lg) then true() else false()"
                                       />
                                    </xsl:call-template>
                                 </sqf:replace>
                              </sqf:fix> <sqf:fix id="fixDivsEverywhere" use-when="self::tei:body">
                                 <sqf:description>
                                    <sqf:title>GLOBAL: Tag all paragraphs within divs and lines
                                       within linegroups.</sqf:title>
                                 </sqf:description>
                                 <sqf:replace
                                    match="//tei:div[not(descendant::*)][not(normalize-space(string-join(text(),''))='')]/node() | //tei:lg[not(descendant::*)][not(normalize-space(string-join(text(),''))='')]/node()">
                                    <xsl:call-template name="tagBlocks">
                                       <xsl:with-param name="verse"
                                          select="if (parent::*/self::tei:lg) then true() else false()"
                                       />
                                    </xsl:call-template>
                                 </sqf:replace>
                              </sqf:fix> </sqf:fixes>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>





               <constraintSpec scheme="schematron" ident="bodyQuotesShouldBeTagged">
                  <constraint>
                     <sch:pattern>
                        <sch:rule
                           context="tei:body[not($isDocumentation)] | tei:*[text()][not(normalize-space(string-join(text(),''))='')][not($isDocumentation) or ($isDocumentation and not(ancestor::tei:back))]">
                           <sch:let name="text"
                              value="string-join(descendant::text()[not(ancestor::tei:code)],'')"/>
                           <sch:let name="containsCurlyQuotes"
                              value="matches($text,'“') and matches($text,'”')"/>
                           <sch:assert test="not($containsCurlyQuotes)"
                              sqf:fix="fixQuotesHere fixQuotesEverywhere"> ERROR: QUICKFIX: Do not
                              use curly quotes; use the q element instead. </sch:assert>
                           <sqf:fix id="fixQuotesHere">
                              <sqf:description>
                                 <sqf:title> LOCAL: Replace curly quotes with q elements in this
                                    <sch:name/> element.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="text()[contains(.,'“') and contains(.,'”')]">
                                 <xsl:call-template name="tagQuote">
                                    <xsl:with-param name="left" select="'“'"/>
                                    <xsl:with-param name="right" select="'”'"/>
                                 </xsl:call-template>
                              </sqf:replace>
                           </sqf:fix>
                           <sqf:fix id="fixQuotesEverywhere" use-when="self::tei:body">
                              <sqf:description>
                                 <sqf:title>GLOBAL: Replace curly quotes with q
                                    elements.</sqf:title>
                              </sqf:description>
                              <sqf:replace match="//text()[contains(.,'“') and contains(.,'”')]">
                                 <xsl:call-template name="tagQuote">
                                    <xsl:with-param name="left" select="'“'"/>
                                    <xsl:with-param name="right" select="'”'"/>
                                 </xsl:call-template>
                              </sqf:replace>
                           </sqf:fix>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>



            </schemaSpec>
         </div>



      </back>
   </text>
</TEI>
